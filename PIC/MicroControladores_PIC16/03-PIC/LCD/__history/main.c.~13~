#include <16F877A.h>
#fuses xt, nowdt
#use delay(crystal=4MHz)

//usaremos el puerto B
#define LCD_DATA_PORT getenv("SFR:PORTC")
#include <lcd.c>

//para el teclado usaremos el puerto B
#byte TRISB=0x86
#byte PORTB=0x06

char comprobar_tecla(int,int);

void main()
{
      //configuración GPIO
      //usamos las resistencias internas del puerto B
      port_b_pullups(true);
      //configurar LCD
      lcd_init();
      lcd_putc("\fLISTO...\n"); //limpio e imprimo listo en el LCD
      //variables localesint 
      filas=4, columnas =4;
      char k=0; //le vamos a meter a esta variable lo que nos devuelva la función

   while(TRUE)
   {
      k=comprobar_tecla(fila,columna);

      
   }

}

char comprobar_tecla(int filas, int columnas){
   char const KEYS[4][4]={{'1', '2', '3', 'A'},
                          {'4', '5', '6', 'B'},
                          {'7', '8', '9', 'C'},
                          {'*', '0', '#', 'A'}
                           };
                           
   char tecla=0; 
   
   TRISB=0x0F; //00001111; los menos significativos entradas, las filas
               //los 4 bits más significativos las salidas, las columnas
   //Para seguir el método, tenemos que tener a 0 una de las salidas
   PORTB=0xFF; //las ponemos todas las salidas a 1 de momento;
   //rotemos el 0 por las 4 salidas
   for(int i=0; i<columna; i++){ //elegimos la columna
      bit_clear(PORTB,i+fila);   //la ponemos a 0
     //comprobamos que fila esta a 0 (botón presionado)
      for(int j=0; j<fila;j++){ //con la columna elegida miramos la fila
         if(bit_test(PORTB, j)==0){
            //le asigno el valor de la matriz
            tecla=KEYS[i][j]; //primero las filas y luego las columnas
            delay_ms(20); //eliminamos rebote
         }
      }
   bit_set(PORTB, i+fila); //lo ponemos a 1
   
   }
   
   
   
   
   
   return tecla;
}



























