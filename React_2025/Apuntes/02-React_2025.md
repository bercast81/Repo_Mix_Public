## 02 GifsApp

> npm create vite

- Elijo React, Typescript + SWC

> npm i

- Limpio la aplicación, dejo solo el main y el index.css (sin lo que lleva)

### Estructura inicial, estilos y fuente

- En src/GifsApp.tsx
- Uso el snippet rafc para crear el componente

~~~js
export const GifsApp = () => {
  return (
    <>
        <div>
            <h1>Buscador de gifs</h1>
            <p>Descubre y comparte el gif perfecto</p>
        </div>
    </>
  )
}

~~~

- Lo coloco en el main

~~~js
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import { GifsApp } from './GifsApp'


createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <GifsApp />
  </StrictMode>,
)
~~~

- Descargo los recursos (css)
- index.css

~~~css
html,
body {
  background-color: #242424;
  color: #fff;
  font-family: 'Montserrat Alternates', sans-serif; /*No tengo esta fuente!*/
}

h1 {
  font-size: 2rem;
  font-weight: 700;
  margin: 0;
  font-style: normal;
  text-align: center;
}

.content-center {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.montserrat-light {
  font-family: 'Montserrat Alternates', sans-serif;
  font-weight: 300;
  font-style: normal;
}

.montserrat-regular {
  font-family: 'Montserrat Alternates', sans-serif;
  font-weight: 400;
  font-style: normal;
}

.montserrat-bold {
  font-family: 'Montserrat Alternates', sans-serif;
  font-weight: 700;
  font-style: normal;
}

.search-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

.search-container input {
  width: 100%;
  max-width: 300px;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 5px;
  font-size: 16px;
  color: #333;
}

.search-container button {
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 5px;
  font-size: 16px;
  color: #333;
  background-color: #000;
  color: #fff;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.search-container button:hover {
  background-color: #333;
  transition: background-color 0.3s ease;
}

/* Trending searches */
.previous-searches {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

.previous-searches-list {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 10px;
  list-style: none;
  padding: 0;
  margin: 0;
  flex-wrap: wrap;
  max-width: 400px;
}

.previous-searches-list li {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 400;
  font-style: normal;
  color: #fff;
  background-color: #000;
  margin-bottom: 20px;
  margin-top: 10px
}

.previous-searches-list li:hover {
  background-color: #333;
  transition: background-color 0.3s ease;
}

/* Gifs */
.gifs-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

.gif-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin-bottom: 50px;
}

.gifs-container img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 10px;
}

@media (min-width: 768px) {
  .gifs-container {
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
  }
}

@media (min-width: 1024px) {
  .gifs-container {
    grid-template-columns: repeat(4, 1fr);
    gap: 30px;
  }
}

@media (min-width: 1280px) {
  .gifs-container {
    grid-template-columns: repeat(5, 1fr);
    gap: 40px;
  }
}
~~~

- Para instalar la fuente ir a Google Fonts a buscar Montserrat Alternates, Get Font, Embeded Code
- Selecciono una Light, una Regular y una Bold
- Las coloco en el index.html

~~~html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates:wght@300;400;700&display=swap" rel="stylesheet">
    <title>Gifs App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
~~~

- Centro el div
- Creo otro div con div.search-container y le coloco un input
- Creo una lista con datos elementos en duro
- Uso unos gifs temporales que facilita Fernando para el div de los gifs

~~~jsx
import { mockGifs } from "./mock-data/gifs.mock"

export const GifsApp = () => {
  return (
    <>
        <div className="content-center">
            <h1>Buscador de gifs</h1>
            <p>Descubre y comparte el gif perfecto</p>
        </div>
        <div className="search-container">
            <input type="text" placeholder="Buscar gifs" />
            <button>Buscar</button>
        </div>
        <div className="previous-searches">
            <h2>Búsquedas previas
                <ul className="previous-searches-list">
                    <li>Goku</li>
                    <li>Saitana</li>
                    <li>Elder Ring</li>
                </ul>
            </h2>
        </div>
        <div className="gifs-container">
            {
                mockGifs.map(gif =>(
                    <div key={gif.id} className="gif-card">
                        <img src={gif.url} alt={gif.title} />
                        <h3>{gif.title}</h3>
                        <p>{gif.width}x{gif.height}</p>
                    </div>
                ))
            }
        </div>
    </>
  )
}
~~~

- Gifs temporales en src/mock-data/gifs.mock.ts

~~~js
export interface Gif {
  id: string;
  title: string;
  url: string;
  width: number;
  height: number;
}

export const mockGifs: Gif[] = [
  {
    id: '1',
    title: "Superman's Cake",
    url: 'https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWVxbHY0dncxMHJlZXRvOTY3MXl5cHp0dWs4aG5iY3d0ZWhlcDM5diZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/0GtVKtagi2GvWuY3vm/giphy.gif',
    width: 300,
    height: 300,
  },
  {
    id: '2',
    title: 'Funny Cat',
    url: 'https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif',
    width: 400,
    height: 250,
  },
  {
    id: '3',
    title: 'Happy BDay!',
    url: 'https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExcG40N2cyZm1iZGM2aWlhbHF1bnZmdzkxZ29idTY3ZzZkbnowNDg4OSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/xatKdEypHxBjzabUPV/giphy.gif',
    width: 280,
    height: 350,
  },
  {
    id: '4',
    title: 'Thumbs Up',
    url: 'https://media.giphy.com/media/3o7abKhOpu0NwenH3O/giphy.gif',
    width: 300,
    height: 200,
  },
  {
    id: '5',
    title: 'Elmo is the best',
    url: 'https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExaG5zMmVsNDFzam56bmR6azl0bmFvbHQxdDczeDNzZTdxczhtejNrNSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/fUQ4rhUZJYiQsas6WD/giphy.gif',
    width: 300,
    height: 400,
  },
  {
    id: '6',
    title: 'Messi is the best',
    url: 'https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExNThyZXBwbHFtdHNpYnh4ZnN0aGswcWJydXNwdnpjaXV0eXNlYXp1YiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/8BSJinJ8of9L0unCqW/giphy.gif',
    width: 350,
    height: 280,
  },
];
~~~

### Pensemos en componentes

- Creemos componentes! Creo src/gifs
- El header no tiene relación directa con lo sgifs, es un componente genérico
- Irá en src/shared/components, lo llamo CustomHeader.tsx
- Lo hago parametrizable para que sea reutilizable
- Como la description es opcional uso && que significa si viene el dato, haz esto
- CustomHeader.tsx

~~~js
interface Props {
title: string
description?: string
}

export const CustomHeader = ({title, description}: Props) => {
  return (
    <div className="content-center">
        <h1>{title}</h1>
        {description && <p>Descubre y comparte el gif perfecto</p>}
    </div>
  )
}
~~~

- Lo incluyo en GifsApp

~~~js
<CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
~~~

- Hago lo mismo con el resto del código
- La search bar en shared/components

~~~js
interface Props{
    placeholder?: string

}

export const SearchBar = ({placeholder='Buscar'}: Props) => {
  return (
     <div className="search-container">
            <input type="text" placeholder={placeholder} />
            <button>Buscar</button>
        </div>
  )
}
~~~

- Hago lo mismo con PreviousSearches en gifs/components
- PreviousSearches.tsx

~~~js
interface Props{
    previousSearches: string[]
}

export const PreviousSearches = ({previousSearches}: Props) => {
  return (
      <div className="previous-searches">
            <h2>Búsquedas previas
                <ul className="previous-searches-list">
                    {previousSearches.map(search=>(
                    <li key={search}>{search}</li>                
                    ))}    
                </ul>
               
            </h2>
        </div>
  )
}
~~~

- Poniendo de key el search, no puedo hacer dos búsquedas iguales (!)
- Ahora tengo que crear el GifsList donde recibiré la data a renderizar como una propiedad
- gifs/components
- GifsList.tsx

~~~js
import type { Gif } from "../../mock-data/gifs.mock"


interface Props{
    gifs: Gif[]
}


export const GifsList = ({gifs}: Props) => {
  return (
    <div className="gifs-container">
            {
                gifs.map(gif =>(
                    <div key={gif.id} className="gif-card">
                        <img src={gif.url} alt={gif.title} />
                        <h3>{gif.title}</h3>
                        <p>{gif.width}x{gif.height}</p>
                    </div>
                ))
            }
    </div>
  )
}
~~~

- Hay otra manera de usar las props que es con FC
- GifsList.tsx

~~~js
import type { FC } from "react"
import type { Gif } from "../../mock-data/gifs.mock"


interface Props{
    gifs: Gif[]
}


export const GifsList: FC<Props> = ({gifs}) => {
  return (
    <div className="gifs-container">
            {
                gifs.map(gif =>(
                    <div key={gif.id} className="gif-card">
                        <img src={gif.url} alt={gif.title} />
                        <h3>{gif.title}</h3>
                        <p>{gif.width}x{gif.height}</p>
                    </div>
                ))
            }
    </div>
  )
}
~~~

- GiffsApp quedaría así

~~~js
import { GifsList } from "./gifs/components/GifsList"
import { PreviousSearches } from "./gifs/components/PreviousSearches"
import { mockGifs } from "./mock-data/gifs.mock"
import { CustomHeader } from "./shared/components/CustomHeader"
import { SearchBar } from "./shared/components/SearchBar"

export const GifsApp = () => {
  return (
    <>
        <CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
        <SearchBar placeholder="Busca gifs" />
        <PreviousSearches previousSearches={['Goku', 'Elder Ring']} />
        <GifsList gifs={mockGifs} />
    </>
  )
}
~~~

- Basamos el filesystem en la funcionalidad de cada módulo, shared, gifs...
- Si solo pusiera una carpeta de components esta crecería mucho

### Manejo de estado - Búsquedas previas

- Si no me interesara que React reaccionara cuando las búsquedas previas cambien podría usar una variable cualquiera
- Pero como cada vez que hago una búsqueda necesito que el arreglo cambie, usaremos un estado
- Lo voy a manejar en minúsculas
- GifsApp

~~~js
import { useState } from "react"
import { GifsList } from "./gifs/components/GifsList"
import { PreviousSearches } from "./gifs/components/PreviousSearches"
import { mockGifs } from "./mock-data/gifs.mock"
import { CustomHeader } from "./shared/components/CustomHeader"
import { SearchBar } from "./shared/components/SearchBar"

export const GifsApp = () => {

  const [previousTerms, setPreviousTerms] = useState(['dragon ball z'])

  return (
    <>
        <CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
        <SearchBar placeholder="Busca gifs" />
        <PreviousSearches previousSearches={previousTerms} />
        <GifsList gifs={mockGifs} />
    </>
  )
}
~~~

- Ahora lo que quiero es que cuando clique encima de una búsqueda previa me la muestre en consola
- Para mandarle una función desde GifsApp (que es dónde tengo el estado de previousSearch, previousTerm le he llamado) debo definirla así en las properties
- PreviousSearches.tsx

~~~js
interface Props{
    previousSearches: string[]
    onLabelClicked: (term: string)=> void
}

export const PreviousSearches = ({previousSearches, onLabelClicked}: Props) => {
  return (
      <div className="previous-searches">
            <h2>Búsquedas previas
                <ul className="previous-searches-list">
                    {previousSearches.map(term=>(
                    <li key={term}
                        onClick={()=> onLabelClicked(term)}
                    >{term}</li>                
                    ))}    
                </ul>
               
            </h2>
        </div>
  )
}
~~~

- En este caso no puedo poner solo la declaración de la función, porque le estoy pasando otro argumento
- Si la función recibe el mismo argumento se puede poner solo la declaración

~~~js
onClick = {(event)=> console.log(event)} 
//es lo mismo que poner esto
onClick = {console.log}
~~~

- Pero en este caso le estoy pasando search, no event, por lo que tengo que usar la función de flecha y pasarle el parámetro
- Le paso el term (la búsqueda previa) a la función en GifsApp
- GifsApp.tsx

~~~js
import { useState } from "react"
import { GifsList } from "./gifs/components/GifsList"
import { PreviousSearches } from "./gifs/components/PreviousSearches"
import { mockGifs } from "./mock-data/gifs.mock"
import { CustomHeader } from "./shared/components/CustomHeader"
import { SearchBar } from "./shared/components/SearchBar"

export const GifsApp = () => {

  const [previousTerms, setPreviousTerms] = useState(['dragon ball z'])
  
  const handleTermClicked = (term: string)=>{
    console.log({term})
  }

  return (
    <>
        <CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
        <SearchBar placeholder="Busca gifs" />
        <PreviousSearches previousSearches={previousTerms} onLabelClicked={handleTermClicked} />
        <GifsList gifs={mockGifs} />
    </>
  )
}
~~~

### Manejo del componente de búsqueda

- El valor del onChange está en event.target.value
- Lo guardo dentro del state
- Llamo a la función onQuery desde el handleSearch, onQuery es la función que el padre me da
- La disparo en el onClick del button
- Para limpiar la caja de texto cuando aprieto el botón uso setQuery con un string vacío
- Uso value para vincular el valor de query con el input, de esta manera se borra la caja del input cuando le doy a Buscar
- SearchBar.tsx

~~~js
import { useState } from "react"

interface Props{
    placeholder?: string
    onQuery: (query:string)=> void

}

export const SearchBar = ({placeholder='Buscar', onQuery}: Props) => {
  
  const [query, setQuery] = useState("")

  const handleSearch = ()=>{
    onQuery(query)
    setQuery('')
  }
  
  return (
     <div className="search-container">
            <input 
              type="text" 
              placeholder={placeholder}
              value={query}
              onChange={(event)=>setQuery(event.target.value)} 
            />
            <button
              onClick={handleSearch}
            >Buscar</button>
        </div>
  )
}
~~~

- Le paso la función onQuery desde GifsApp 
- Recuerda, le paso solo la referencia porque el argumento de la función de flecha y el de la función que dispara son el mismo
- GifsApp.tsx

~~~js
import { useState } from "react"
import { GifsList } from "./gifs/components/GifsList"
import { PreviousSearches } from "./gifs/components/PreviousSearches"
import { mockGifs } from "./mock-data/gifs.mock"
import { CustomHeader } from "./shared/components/CustomHeader"
import { SearchBar } from "./shared/components/SearchBar"

export const GifsApp = () => {

  const [previousTerms, setPreviousTerms] = useState(['dragon ball z'])

  const handleTermClicked = (term: string)=>{
    console.log({term})
  }

  const handleSearch = (query: string)=>{
    console.log({query})
  }

  return (
    <>
        <CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
        <SearchBar placeholder="Busca gifs" onQuery={handleSearch}/>
        <PreviousSearches previousSearches={previousTerms} onLabelClicked={handleTermClicked} />
        <GifsList gifs={mockGifs} />
    </>
  )
}
~~~

- Uso onKeyDown para usar el "Enter" para disparar también el handleSearch
- Para saber qué nombre recibe la tecla puedo usar un console.log(event) desde el evento onKeyDown
- SearchBar.tsx

~~~js
import { useState } from "react"

interface Props{
    placeholder?: string
    onQuery: (query:string)=> void

}

export const SearchBar = ({placeholder='Buscar', onQuery}: Props) => {
  
  const [query, setQuery] = useState("")

  const handleSearch = ()=>{
    onQuery(query)
    setQuery('')
  }
  
  return (
     <div className="search-container">
            <input 
              type="text" 
              placeholder={placeholder}
              value={query}
              onChange={(event)=>setQuery(event.target.value)} 
              onKeyDown={(event)=>{
                if(event.key==="Enter"){
                  handleSearch()
                }
              }}
            />
            <button
              onClick={handleSearch}
            >Buscar</button>
        </div>
  )
}
~~~

- Ahora si pongo algo en el input y presiono Enter me lo imprime en consola
- Es preferible no meter mucha lógica en los componentes
- Para saber el tipo de evento que es el de keyDown, **poner el cursor encima del event**
- Importo KeyboardEvent para el tipo, sin importación sería React.keyboardEvent
- SearchBar.tsx

~~~js
import { useState, type KeyboardEvent } from "react"

interface Props{
    placeholder?: string
    onQuery: (query:string)=> void

}

export const SearchBar = ({placeholder='Buscar', onQuery}: Props) => {
  
  const [query, setQuery] = useState("")

  const handleSearch = ()=>{
    onQuery(query)
    setQuery('')
  }

  const handleKeyDown= (event: KeyboardEvent<HTMLInputElement>)=>{
    if(event.key==="Enter"){
                  handleSearch()
      }
  }
  
  return (
     <div className="search-container">
            <input 
              type="text" 
              placeholder={placeholder}
              value={query}
              onChange={(event)=>setQuery(event.target.value)} 
              onKeyDown={handleKeyDown}
            />
            <button
              onClick={handleSearch}
            >Buscar</button>
        </div>
  )
}
~~~

### useEffect - Debounce

- useEffect ejecuta efectos secundarios, también sirve para limpiar cuando se desmonta el componente
- Se ejecuta al menos una vez, cuando se renderiza el componente
- Se le puede añadir una dependencia dentro de un arreglo, para que cada vez que esa propiedad cambie disparar el useEffect
- El return se usa para la tarea de limpieza, cuando el componente va a dejar de montar o se va a volver a disparar el efecto
- Cada useEffect hace una tarea en específico
- Si se quieren hacer varias cosas es mejor usar varios useEffect
- Quiero hacer el envío del onQuery cuando la persona deja de escribir por un tiempo (es decir, hacer la petición HTTP)
  - Hay otras técnicas para hacer llamadas HTTP cuando se renderiza el componente
- Esto es lo que se conoce como un **debounce**
- La idea es usar un setTimeout
- Uso la limpieza para cuando se vuelva a disparar el efecto, para que no se ejecute el setTimeout (no necesito dispararlo)
- La dependencia de este useEffect es el query (cada vez que escribo, cambia el state)

~~~js
import { useState, useEffect, type KeyboardEvent } from "react"

interface Props{
    placeholder?: string
    onQuery: (query:string)=> void

}

export const SearchBar = ({placeholder='Buscar', onQuery}: Props) => {
  
  const [query, setQuery] = useState("")

  useEffect(() => {
   const timeoutId=  setTimeout(()=>{
      onQuery(query)
    }, 1000) //1 segundo

    return()=>{
      clearTimeout(timeoutId)
    }
  },[query,onQuery])
  

  const handleSearch = ()=>{
    onQuery(query)
    setQuery('')
  }

  const handleKeyDown= (event: KeyboardEvent<HTMLInputElement>)=>{
    if(event.key==="Enter"){
                  handleSearch()
      }
  }
  
  return (
     <div className="search-container">
            <input 
              type="text" 
              placeholder={placeholder}
              value={query}
              onChange={(event)=>setQuery(event.target.value)} 
              onKeyDown={handleKeyDown}
            />
            <button
              onClick={handleSearch}
            >Buscar</button>
        </div>
  )
}
~~~

### Ver búsquedas previas

- Hay que implementar handleSearch
  - Validar que el query no esté vacío
  - Convertir el query a minúsculas
  - Evitar búsquedas duplicadas 
  - Actualizar previousTerms agregando el nuevo término al inicio del array y limitando a 8 elementos máximo
- GifsApp.tsx

~~~js
const handleSearch = (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) //uso splice para cortar el arreglo en 8
    
  }
~~~

### Giphy Developers API KEY

- Web: Giphy Developers
- Create API Key / Selecciono API (SDK es más robusto)
- La guardo en .env (agrego también un .env.template)
- En la pestaña API Explorer puedes probar con tu propia api key la url de búsqueda
  - Choose a resource: Public API
  - Choose an endpoint: Search
- Copio la url, que es lo que necesito para hacer mi petición. Pongamos que busco goku con lenguaje en español

> https://api.giphy.com/v1/gifs/search?api_key=MI_API_KEY&q=goku&limit=25&offset=0&rating=g&lang=es&bundle=messaging_non_clips

- Con Send Request puedo ver el JSON de la respuesta desde la web
- Si en POSTMAN copio el url en una petición GET me indica los Query parameters (api_key, q, limit, offset, rating, lang, bundle) 
- Pongo el limit 10
  -  Me quedo solo con api_key, q, limit, lang
- Me queda esta URL

> https://api.giphy.com/v1/gifs/search?api_key=MI_API_KEY&q=goku&limit=10&lang=es

- La data en la respuesta está en un arreglo llamado data
- Mi interfaz de Gif luce así

~~~js
export interface Gif {
  id: string;
  title: string;
  url: string;
  width: number;
  height: number;
}
~~~

- No conviene usar directamente la data de la API porque si algo cambia se rompa la app
- Copio la respuesta y uso PasteJsonAsCode
- Cambio Datum por GiphyGif, **apreto F2 encima de la palabra que quiero cambiar en todas partes**
- Corrijo los errores y los tipo como strings (son strings)
- gifs/interfaces/giphy.response.ts

~~~js
export interface GiphyResponse {
    data:       GiphyGif[];
    meta:       Meta;
    pagination: Pagination;
}

export interface GiphyGif {
    type:                       string;
    id:                         string;
    url:                        string;
    slug:                       string;
    bitly_gif_url:              string;
    bitly_url:                  string;
    embed_url:                  string;
    username:                   string;
    source:                     string;
    title:                      string;
    rating:                     string;
    content_url:                string;
    source_tld:                 string;
    source_post_url:            string;
    source_caption?:            string;
    is_sticker:                 number;
    import_datetime:            Date;
    trending_datetime:          string;
    images:                     Images;
    user?:                      User;
    analytics_response_payload: string;
    analytics:                  Analytics;
    alt_text:                   string;
    is_low_contrast:            boolean;
}

export interface Analytics {
    onload:  Onclick;
    onclick: Onclick;
    onsent:  Onclick;
}

export interface Onclick {
    url: string;
}

export interface Images {
    original:                 FixedHeight;
    downsized:                The480_WStill;
    downsized_large:          The480_WStill;
    downsized_medium:         The480_WStill;
    downsized_small:          DownsizedSmall;
    downsized_still:          The480_WStill;
    fixed_height:             FixedHeight;
    fixed_height_downsampled: FixedHeight;
    fixed_height_small:       FixedHeight;
    fixed_height_small_still: The480_WStill;
    fixed_height_still:       The480_WStill;
    fixed_width:              FixedHeight;
    fixed_width_downsampled:  FixedHeight;
    fixed_width_small:        FixedHeight;
    fixed_width_small_still:  The480_WStill;
    fixed_width_still:        The480_WStill;
    looping:                  Looping;
    original_still:           The480_WStill;
    original_mp4:             DownsizedSmall;
    preview:                  DownsizedSmall;
    preview_gif:              The480_WStill;
    preview_webp:             The480_WStill;
    hd?:                      DownsizedSmall;
    "480w_still":             The480_WStill;
}

export interface The480_WStill {
    height: string;
    width:  string;
    size:   string;
    url:    string;
}

export interface DownsizedSmall {
    height:   string;
    width:    string;
    mp4_size: string;
    mp4:      string;
}

export interface FixedHeight {
    height:    string;
    width:     string;
    size:      string;
    url:       string;
    mp4_size?: string;
    mp4?:      string;
    webp_size: string;
    webp:      string;
    frames?:   string;
    hash?:     string;
}

export interface Looping {
    mp4_size: string;
    mp4:      string;
}



export interface User {
    avatar_url:    string;
    banner_image:  string;
    banner_url:    string;
    profile_url:   string;
    username:      string;
    display_name:  string;
    description:   string;
    instagram_url: string;
    website_url:   string;
    is_verified:   boolean;
}



export interface Meta {
    status:      number;
    msg:         string;
    response_id: string;
}

export interface Pagination {
    total_count: number;
    count:       number;
    offset:      number;
}
~~~

## Obtener gifs mediante HTTP

- Las interfaces no hacen transformación de data
- La petición http estará en su archivo independiente donde están las acciones que quiero disparar en gifs/actions/get-gifs-by-query.action.ts
- Es una función asíncrona porque tengo que llegar al backend y traer la data
- Yo podría hacer esto

~~~js
export const getGifsByQuery = async (query: string)=>{

    fetch(`https://api.giphy.com/v1/gifs/search?api_key=MI_API_KEY&q=${query}&limit=10&lang=es`)
}
~~~

- Mejor usemos axios

> npm i axios

- Uso solo la url hast search
- Uso un objeto params para indicarle los parámetros de api_key, limit, etc
- Ahora tengo la data en response.data.data (la primera data es la de axios)
- Como data es un arreglo dispongo de todos los métodos de los arreglos
- Entonces, esto ya es un gif

~~~js
response.data.data[0]
~~~

- get-gifs-by-query.action.ts

~~~js
import axios from "axios"
import type { GiphyResponse } from "../interfaces/giphy.response"


export const getGifsByQuery = async (query: string)=>{

    const response = await axios.get<GiphyResponse>(`https://api.giphy.com/v1/gifs/search`, {
        params:{
            q:query,
            limit:10,
            lang:"es",
            api_key: 'mi_api_key' //aqui va mi api key
        }
    })
    console.log(response.data)
}
~~~

- ¿Dónde lo llamo? En handleSearch en GifsApp

~~~js
const handleSearch = async (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) //uso splice para cortar el arreglo en 8

    await getGifsByQuery(query)
    
  }
~~~

- Si hago una búsqueda me aparece un arreglo de 10 gifs
- Tenemos que transformar la data para que sean compatibles con nuestra interfaz
- Creo en gifs/interfaces/gif.interface.ts

~~~js
export interface Gif {
  id: string;
  title: string;
  url: string;
  width: number;
  height: number;
}
~~~

- Tipo con esta interfaz el retorno de la función con la petición de axios

~~~js
import axios from "axios"
import type { GiphyResponse } from "../interfaces/giphy.response"
import type { Gif } from "../interfaces/gif.interface"


export const getGifsByQuery = async (query: string): Promise<Gif[]>=>{

    const response = await axios.get<GiphyResponse>(`https://api.giphy.com/v1/gifs/search`, {
        params:{
            q:query,
            limit:10,
            lang:"es",
            api_key: '36c67xVQWyJ8Wm1btXpK1E6u9VO1xBLt'
        }
    })

    return response.data.data.map((gif)=>({
        id: gif.id,
        title: gif.title ,
        url: gif.images.original.url,
        width: Number(gif.images.original.width),
        height: Number(gif.images.original.height),
    }))
}
~~~

- En el handleSearch, en GifsApp

~~~js
  const handleSearch = async (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) //uso splice para cortar el arreglo en 8

    const gifs =await getGifsByQuery(query)

    console.log({gifs})
    
  }
~~~

### Variables de entorno

- A la variable de entorno, para que sea pública y no se quede en el entorno de Node, hay que ponerle VITE al principio
- Puedo poner el url encima comentada como documentación
- .env
~~~
# https://developers.giphy.com/dashboard/
VITE_GIFS_APIKEY=
~~~

- Añado .env a .gitignore
- Hago una copia con .env.template sin el valor de la api_key
- Para usar la API_KEY voy a la función de axios

~~~js
import axios from "axios"
import type { GiphyResponse } from "../interfaces/giphy.response"
import type { Gif } from "../interfaces/gif.interface"


export const getGifsByQuery = async (query: string): Promise<Gif[]>=>{

    const response = await axios.get<GiphyResponse>(`https://api.giphy.com/v1/gifs/search`, {
        params:{
            q:query,
            limit:10,
            lang:"es",
            api_key: import.meta.env.VITE_GIFS_APIKEY
        }
    })

    return response.data.data.map((gif)=>({
        id: gif.id,
        title: gif.title ,
        url: gif.images.original.url,
        width: Number(gif.images.original.width),
        height: Number(gif.images.original.height),
    }))
}
~~~

- Es buena práctica crear una instancia de axios para no duplicar código
- La baseURL es hasta gifs, porque search ya es una función
- Esto va a ser base para todas mis peticiones HTTP
- En gifs/api/giphy.api.ts

~~~js
import axios from "axios";


export const giphyApi = axios.create({
    baseURL: 'https://api.giphy.com/v1/gifs',
    params:{
        lang: 'es',
        api_key: import.meta.env.VITE_GIFS_APIKEY
    }
})
~~~

- En get-gifs-by-query.action.ts

~~~js
import type { GiphyResponse } from "../interfaces/giphy.response"
import type { Gif } from "../interfaces/gif.interface"
import { giphyApi } from "../api/giphy.api"


export const getGifsByQuery = async (query: string): Promise<Gif[]>=>{

    const response = await giphyApi<GiphyResponse>(`/search`, {
        params:{
            q:query,
            limit:10,
        }
    })

    return response.data.data.map((gif)=>({
        id: gif.id,
        title: gif.title ,
        url: gif.images.original.url,
        width: Number(gif.images.original.width),
        height: Number(gif.images.original.height),
    }))
}
~~~

- Vamos a mostrar los gifs!
- En GifsApp (donde tengo los gifs) creo un state para guardar los gifs, lo tipo con la interfaz como un arreglo de gifs
- Uso setGifs para guardar en el state los Gifs
- Se lo paso al componente GifsList

~~~js
import { useState } from "react"
import { GifsList } from "./gifs/components/GifsList"
import { PreviousSearches } from "./gifs/components/PreviousSearches"
import { mockGifs } from "./mock-data/gifs.mock"
import { CustomHeader } from "./shared/components/CustomHeader"
import { SearchBar } from "./shared/components/SearchBar"
import { getGifsByQuery } from "./gifs/actions/get-gifs-by-query.action"
import type { Gif } from "./gifs/interfaces/gif.interface"

export const GifsApp = () => {

  const [previousTerms, setPreviousTerms] = useState(['dragon ball'])

  const [gifs, setGifs] = useState<Gif[]>([])

  const handleTermClicked = (term: string)=>{
    console.log({term})
  }

  const handleSearch = async (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) //uso splice para cortar el arreglo en 8

    const gifs =await getGifsByQuery(query)

    setGifs(gifs)
    
  }

  return (
    <>
        <CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
        <SearchBar placeholder="Busca gifs" onQuery={handleSearch}/>
        <PreviousSearches previousSearches={previousTerms} onLabelClicked={handleTermClicked} />
        <GifsList gifs={gifs} />
    </>
  )
}
~~~

- 