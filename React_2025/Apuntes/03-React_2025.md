## 03 GiffsApp- Optimización y despliegue

- Hay demasiada lógica en GifApp.tsx, es mejor separar la lógica
- Además usaremos un custom hook. Creo src/gifs/hooks/useGifs.tsx
- Corto y pego la lógica en el hook, retorno un objeto con lo que me interesa usar
- Con Ctrl + . "All missing imports" hace todas las importaciones

~~~js
import { useState } from "react"
import { getGifsByQuery } from "../actions/get-gifs-by-query.action"
import type { Gif } from "../interfaces/gif.interface"

export const useGifs=()=>{

  const [previousTerms, setPreviousTerms] = useState<string[]>([])

  const [gifs, setGifs] = useState<Gif[]>([])

  const handleTermClicked = (term: string)=>{
    console.log({term})
  }

  const handleSearch = async (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) //uso splice para cortar el arreglo en 8

    const gifs =await getGifsByQuery(query)

    setGifs(gifs)
    
  }
  return{
    gifs, //properties arriba métodos abajo (para mantener un orden)
    previousTerms,
    handleTermClicked,
    handleSearch
  }
}
~~~

- En GifsApp, el componente queda mucho más limpio

~~~js
import { GifsList } from "./gifs/components/GifsList"
import { PreviousSearches } from "./gifs/components/PreviousSearches"
import { CustomHeader } from "./shared/components/CustomHeader"
import { SearchBar } from "./shared/components/SearchBar"

import { useGifs } from "./gifs/hooks/useGifs"

export const GifsApp = () => {

  const {gifs, previousTerms, handleTermClicked, handleSearch} = useGifs()

  return (
    <>
        <CustomHeader title="Buscador de Gifs" description="Descubre y comparte el gif perfecto" />
        <SearchBar placeholder="Busca gifs" onQuery={handleSearch}/>
        <PreviousSearches previousSearches={previousTerms} onLabelClicked={handleTermClicked} />
        <GifsList gifs={gifs} />
    </>
  )
}
~~~

### Manejo en caché

- En el useGifs uso Record para tipar el objeto del caché, piensa en un objeto tal que asi
- También funcionaría con Map

~~~js
const gifsCache ={
    goku: ["arreglo_con_los_gifs"]
}

const gifsCache: Record<string, Gif[]> ={} 
~~~

- gifsCache es un objeto literal, por lo que cada vez que se vuelve a renderizar no actúa como el state, sino que ocupa un nuevo espacio en memoria. Se pierde la info previamente buscada
- Como solo lo usamos como espacio en caché, lo podemos sacar fuera del ciclo de vida de React sacándolo del hook
- Cuando el customHook se vuelva a re-renderizar gifsCache no va a ocupar un nuevo espacio en memoria
- Guardo los gifs en el objeto de caché en el handleSearch en la posición del query
- Y en el handleTermClicked, que se dispara cuando le doy a una de las previousSearch, compruebo si está el objeto en caché y se lo paso al setGifs

~~~js
import { useState } from "react"
import { getGifsByQuery } from "../actions/get-gifs-by-query.action"
import type { Gif } from "../interfaces/gif.interface"

const gifsCache: Record<string, Gif[]> ={} 

export const useGifs=()=>{

  const [previousTerms, setPreviousTerms] = useState<string[]>([])
  const [gifs, setGifs] = useState<Gif[]>([])


  const handleTermClicked = (term: string)=>{
    //nuevo state desde previousSearch
    if(gifsCache[term]){
        setGifs(gifsCache[term])
    }
    return
  }

  const handleSearch = async (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) 

    const gifs =await getGifsByQuery(query)

    setGifs(gifs)

    gifsCache[query] = gifs //guardo los gifs en caché
    
  }

  return{
    gifs,
    previousTerms,
    handleTermClicked,
    handleSearch
  }

}
~~~

- Hay un hook específico para no tener que sacar el caché fuera del componente, useRef

### useRef - Mantener el valor entre renderizados

- Puedo tipar el useRef igual
- Debo usar .current para apuntar al objeto 

~~~js
import { useRef, useState } from "react"
import { getGifsByQuery } from "../actions/get-gifs-by-query.action"
import type { Gif } from "../interfaces/gif.interface"



export const useGifs=()=>{

  const [previousTerms, setPreviousTerms] = useState<string[]>([])
  const [gifs, setGifs] = useState<Gif[]>([])
    const gifsCache = useRef<Record<string, Gif[]>>({})

  const handleTermClicked = (term: string)=>{

    if(gifsCache.current[term]){
        setGifs(gifsCache.current[term])
    }
    return
  }

  const handleSearch = async (query: string)=>{
    query = query.toLowerCase().trim()
    
    if(query.length === 0) return

    if(previousTerms.includes(query)) return

    setPreviousTerms([query, ...previousTerms].splice(0,7)) //uso splice para cortar el arreglo en 8

    const gifs =await getGifsByQuery(query)

    setGifs(gifs)

    gifsCache.current[query] = gifs //guardo los gifs en caché
    
  }

  return{
    gifs,
    previousTerms,
    handleTermClicked,
    handleSearch
  }

}
~~~

- Otro uso muy común del useRef es asignar una referencia a un elemento HTML

### Generar versión de producción

> npm run build

- Esto crea la carpeta dist
- Me da un error de importación el GifList, lo arreglo con

> import type { Gif } from "../interfaces/gif.interface"

- Para probar el build de producción puedo montar un pseudo-backend con npm i -g http-server
- Se usa (en la ubicación en la terminal donde está la carpeta dist)

> npx http-server -o
