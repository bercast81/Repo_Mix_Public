## Context API - Búsquedas y favoritos

- Trabajemos en el manejo de los favoritos
- Hay un porcentaje en pantalla además del número de favoritos
- Tenemos el botón de corazoncito (lleno-vacío) para marcar héroe favorito (que debe cambiar el número de favoritos y el porcentaje)
- También tenemos la Tab de Favoritos

### Contexto para control de favoritos

- Voy a necesitar en varios componentes la data de hero
- Es raro pasarle info a un Layout (desde el router). Los layouts están relacionados solo con la parte visual
- Usemos el context, creo la carpeta heroes/context/FavoriteHeroContext.tsx
- Debo colocar en el value el objeto que he tipado como FavoriteHeroCOntext
- No hace falta ponerle .Provider al FavoriteHeroContext

~~~js
import { createContext } from "react";
import type { Hero } from "../types/hero.interface";
import { useState, type PropsWithChildren } from "react";

interface FavoriteHeroContext {
    //State
    favorites: Hero[],
    favoriteCount: number,

    //Methods
    isFavorite: (hero: Hero)=> boolean
    toggleFavorite: (hero: Hero)=> void
}

export const FavoriteHeroContext = createContext({} as FavoriteHeroContext)

export const FavoriteHeroProvider =({children}: PropsWithChildren) =>{
    return(
        <FavoriteHeroContext value={{
           //FavoriteHeroContext state & methods
        }}>
            {children}
        </FavoriteHeroContext>
    )
}
~~~

- Uso esta manera para no tener que declarar el objeto 

~~~js
//export const FavoriteHeroContext = createContext<FavoriteHeroContext>({tendría que crear el objeto aquí})
export const FavoriteHeroContext = createContext({} as FavoriteHeroContext)
~~~

- Creo los métodos, le paso los states y los métodos al objeto value

~~~js
import { createContext } from "react";
import type { Hero } from "../types/hero.interface";
import { useState, type PropsWithChildren } from "react";

interface FavoriteHeroContext {
    //State
    favorites: Hero[],
    favoriteCount: number,

    //Methods
    isFavorite: (hero: Hero)=> boolean
    toggleFavorite: (hero: Hero)=> void
}

export const FavoriteHeroContext = createContext({} as FavoriteHeroContext)

export const FavoriteHeroProvider =({children}: PropsWithChildren) =>{

  const [favorites, setFavorites] = useState<Hero[]>([])

  const toggleFavorite = (hero: Hero)=>{
    const heroExist = favorites.find(h=> h.id === hero.id)
    //si el héroe existe lo tengo que eliminar y si no lo tengo que insertar
    if(heroExist){
        const newFavorites = favorites.filter(r=> r.id != hero.id) //filtro el arreglo para eliminar el heroe
        setFavorites(newFavorites)
        return
    }

    //si el heroe no está lo agrego
    setFavorites([...favorites, hero])
}

const isFavorite =(hero:Hero)=>{
   return favorites.some(h=>h.id === hero.id) //some regresa un true o false
}

    return(
        <FavoriteHeroContext value={{
            favoriteCount: favorites.length,
            favorites,
            toggleFavorite,
            isFavorite
        }}>
            {children}
        </FavoriteHeroContext>
    )
}
~~~

- Vamos a consumir el Context
- Envuelvo toda la aplicación

~~~js
import { RouterProvider } from "react-router"
import { appRouter } from "./router/app.router"
import {QueryClient, QueryClientProvider} from '@tanstack/react-query'
import {ReactQueryDevtools} from "@tanstack/react-query-devtools"
import { FavoriteHeroProvider } from "./heroes/context/FavoriteHeroContext"

const queryClient = new QueryClient()

export const HeroesApp = () => {


  return (
    <QueryClientProvider client={queryClient}>
      <FavoriteHeroProvider>
        <RouterProvider router={appRouter}/>
        <ReactQueryDevtools initialIsOpen={false} />
      </FavoriteHeroProvider>
    </QueryClientProvider>
  )
}
~~~

- Creo una función para obtener los favoritos del localStorage en el context
- Inicializo el state con la función

~~~js
export const FavoriteHeroProvider =({children}: PropsWithChildren) =>{

const getFavoritesFromLocaltorage = (): Hero[]=>{
    const favorites = localStorage.getItem('favorites')
    return favorites ? JSON.parse(favorites) : []
}    
    
const [favorites, setFavorites] = useState<Hero[]>(getFavoritesFromLocaltorage())

{...code}
}
~~~

- Uso el useEffect para disparar un efecto cada vez que los favorites (state) cambien
- Le añado como dependencia favorites (!)

~~~js
useEffect(()=>{
    localStorage.setItem('favorites', JSON.stringify(favorites))
}, [favorites])
~~~

- De esta manera, cada vez que hagamos algún cambio al arreglo de favorites se va a guardar en el localStorage

### Consumir el contexto de favoritos

- Trabajemos en el icono del corazón, nos permitirá trabajar con el total de favoritos y lo demás
- Vamos a heroes/components/HeroCard y usemos el contexto
- No se aconseja usar el useContext si no el **use**
- El use no es un hook por lo que se podría poner dentro de un condicional
- heroes/components/HeroCard

~~~js
const {isFavorite, toggleFavorite} = use(FavoriteHeroContext)
~~~

- En el componente Button que contiene el Heart añado el onClick
- A toggleFavorite le paso el hero que recibe el componente de heroCard
- No la paso por referencia (la función) porque si lo hiciera le estaría pasando el evento y no es lo que quiero

~~~js
 <Heart className="h-4 w-4 fill-red-500 text-red-500" 
   
/>
~~~

- isFavorite es una función, le paso el hero
- Hago la condición para pintar el corazón de rojo

~~~js
{/* Favorite button */}
<Button size="sm" variant="ghost" 
    className="absolute bottom-3 right-3 bg-white/90 hover:bg-white"
    onClick={()=>toggleFavorite(hero)}
    >
    <Heart className={`h-4 w-4 ${isFavorite(hero) ? 'fill-red-500 text-red-500': 'text-gray-500'} `} 
    />
</Button>
~~~

- Ahora debo cambiar el número de heroes del HeroStats (la parte de arriba) y de las Tabs (la Tab Favorites)
- En el HeroStats desestructuro del context el favoriteCount
- Calculo el %, lo coloco en el componente

~~~js
const {data: summary} = useHeroSummary()

if(!summary){
   return  <h1>Loading...</h1> //evalúo si hay un summary para que summary.totalHeroes no de error
  }

const {favoriteCount} = use(FavoriteHeroContext)

const percentage = ((favoriteCount / summary.totalHeroes)*100).toFixed(2)

{...code}

<HeroStatCard 
    title="Favorites" 
    icon={<Heart className="h-4 w-4 text-muted-foreground" />}
    >
        <div className="text-2xl font-bold text-red-600">{favoriteCount}</div>
        <p className="text-xs text-muted-foreground mt-3">{percentage}% del total</p>
</HeroStatCard>
~~~

- Obtengo la data que renombro a summary usando el useHeroSummary que es un llamado con useQuery
- hooks/useHeroSummary

~~~js
import { useQuery } from "@tanstack/react-query"
import { getSummaryAction } from "../actions/get-summary.action"


export const useHeroSummary = () => {
    return useQuery({
    queryKey:['summary-information'],
    queryFn: ()=> getSummaryAction(),
    staleTime: 1000 * 60 * 5 //5 minutos
  })
}
~~~

- getSummaryAcyion simplemente hace un llamado con axios

~~~js
import { heroApi } from "../api/hero.api"
import type { SummaryInformationResponse } from "../types/summary-information.response"

export const getSummaryAction = async ()=>{

    const {data} = await heroApi.get<SummaryInformationResponse>('/summary')

    return data
}
~~~

- Para las Tabs está en el HomePage, desestructuro el favoriteCount
- Nota, el favoriteCount las llaves están entre paréntesis para que en la interfaz el número se vea entre paréntesis

~~~js
<TabsTrigger 
    onClick={()=>setSearchParams((prev)=>{
    prev.set('tab', 'favorites');
    return prev
    })}
    value="favorites" className="flex items-center gap-2">
    <Heart className="h-4 w-4" />
    Favorites ({favoriteCount})
</TabsTrigger>
~~~

- Puedo desestructurar también con el use el arreglo de favoritos y renderizarlo

~~~js
</TabsContent>
    <TabsContent value="favorites">
    {/*Mostrar los personajes favoritos*/}
    <HeroGrid heroes={favorites}/>
</TabsContent>
~~~

- Puedo no mostrar la paginación si está en la tab de favoritos
- Agrego un condicional

~~~js
  {/* Pagination */}
{selectedTab != 'favorites' && (
    <CustomPagination totalPages={heroesResponse?.pages ?? 2}/>
)}
~~~

### useRef - en valores de inputs 

- Vamos a trabajar con la búsqueda
- En la app tengo la barra de búsqueda y luego tengo los filtros
- Para los filtros usaremos la misma técnica de los params en la URL
- heroes/pages/search/ui/SearchControls.tsx
- Lo normal sería usar el useState para el input

~~~js
export const SearchControls = () => {

  const [query, setQuery] = useState('')

  return (
    <>
    
<div className="flex flex-col lg:flex-row gap-4 mb-8">
    {/* Search */}
    <div className="relative flex-1">
    <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
    <Input placeholder="Search heroes, villains, powers, teams..." className="pl-12 h-12 text-lg" 
        value={query}
        onChange={(event)=>setQuery(event.target.value)}
        />
</div>

{...code}
)}
~~~

- Pero en realidad **no necesito que sea un state**, no necesito que aparezca en ningún lugar ni que esté sujeto a cambios
- Crearemos una referencia al input mediante useRef
- No necesito el value ni el onChange, pero si ocupo saber cuando se presiona Enter para realizar la búsqueda
- Si sitúo el ratón encima del event en el callback de onKeyDown obtengo el tipo
- Creo la función y uso React. para el tipado del evento 
- Uso useSearchParams, extraigo las funciones

~~~js
export const SearchControls = () => {

  const inputRef = useRef<HTMLInputElement>(null)

  const [searchParams, setSearchParams] = useSearchParams()
 
  const handleKeyDown=(event: React.KeyboardEvent<HTMLInputElement> )=>{
    
    if(event.key === 'Enter'){
      const value = inputRef.current?.value ?? '' //tomo el valor si no viene nada pongo un string vacío
      
      setSearchParams(prev=>{ //mantengo el valor previo de los params
        prev.set('name', value) //lo seteo en la URL
        return prev
      })
    }
  }
  return (
    <>
    
    <div className="flex flex-col lg:flex-row gap-4 mb-8">
    {/* Search */}
    <div className="relative flex-1">
    <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
    <Input placeholder="Search heroes, villains, powers, teams..." className="pl-12 h-12 text-lg" 
        ref={inputRef}
        onKeyDown={handleKeyDown}
        //obtengo como valor por defecto el name y si no viene un string vacío
        defaultValue={searchParams.get('name') ?? ''} 
        />
    </div>
    {...code}

</>)}
~~~

- De esta manera, obteniendo como defaultValue el name, si en la URL tengo name=Batman, aparece Batman en la barra de búsqueda 

### Buscar héroes por nombre

- En los filtros voy a poder buscar por Team, Category, Universe y Status
- Empecemos por la búsqueda por nombre
- api/heroes/search necesita algún parámetro de búsqueda
- api/heroes/search/ puedo poner name, team, category, universe, status o strength (mirado en el dto del backend)
- api/heroes/search?name=bat&strength=6
- Creo en heroes/actions/search-hero.action.ts

~~~js
import { heroApi } from "../api/hero.api"
import type { Hero } from "../types/hero.interface"

//querys disponibles
interface Options{
    name?: string
    team?: string
    category?: string
    universe?: string
    status?: string
    strength?: string
}

const BASE_URL = import.meta.env.VITE_API_URL

export const searchHeroAction = async ({name, team, category, universe, status, strength}: Options)=>{

    if(!name && !team && !category && !universe && !status && !strength){
        return [] //para evitar que regrese un 400 por no tener ningún param al inicio
    } 


    const {data} = await heroApi.get<Hero[]>('/search',{
        params:{
            name, 
            team, 
            category, 
            universe, 
            status, 
            strength
        }
    })

    return data.map(hero=>({
        ...hero,
        image: `${BASE_URL}/images/${hero.image}`
    }))
}
~~~

- En SearchPage uso useQuery de tanstack query
- Obtengo con searchParams el name de la URL
- Se lo paso como un objeto al queryKey, ya que habrán otros (team, category, etc)
- heroes/pages/search/SearchPage.tsx

~~~js
const SearchPage = () => {

  const [searchParams] = useSearchParams()

  const name = searchParams.get('name') ?? undefined

  const {data:heroes = []} = useQuery({
    queryKey: ['search', {name}],
    queryFn: ()=> searchHeroAction({name}),
    staleTime: 1000 * 60 * 5
  })

  return (
    {...code}
    <HeroGrid heroes={heroes}/>
  )}
~~~

- Si en la página de búsqueda de héroes pongo bat en la barra de búsqueda me muestra tres resultados (Batichcia , Batman y Shazam. que se llama Billt Batson)
- Guarda la info en caché
- También si alguien comparte el URL, al tenerlo organizado por parámetros en la URL, se mantienen los resultados

### Componentes de búsqueda adicionales

- Quiero hacer clic en Filters y que aparezcan los Filtros Avanzados con una animación
- Tampoco funciona la barra de slide que hay abajo de Strength
- Hay que importar el accordion y el slider de shadcn

> npx shadcn@latest add

- Selecciono accordion y slider
- Empecemos con el Slider en pages/search/ui/SearchControls.tsx
- Lo coloco en el div donde estaba antes el slider que no funcionaba
- Lo importo de los ui/components, no de radixUI

~~~js
<Slider defaultValue={[5]} max={10} step={1} />
~~~

- Para el acordion tiene el type (single, la propiedad collapsible y el defaultValue que sería la opción abierta por defecto)
- En SearchControls hago las importaciones de la documentación de shadcn y copio el código

~~~js
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion"
~~~

- En este componente (ejemplo de la documentación) tenemos que envolver los AdvancedFilters en SearchControls.tsx
~~~js
<Accordion type="single" collapsible>
    <AccordionItem value="item-1">
    <AccordionTrigger>Is it accessible?</AccordionTrigger>
        <AccordionContent>
            Yes. It adheres to the WAI-ARIA design pattern.
        </AccordionContent>
    </AccordionItem>
</Accordion>
~~~

- Con este componente solo veo en pantalla "Is it visible?" y si clico encima se despliega "Yes, etc..."
- Dentro de AccordionContent puedo colocar lo que tenía de AdvancedFilters

~~~js
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Slider } from "@/components/ui/slider"
import { Filter, Grid, Plus, Search, SortAsc } from "lucide-react"
import { useRef } from "react"
import { useSearchParams } from "react-router"
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion"

export const SearchControls = () => {

  const inputRef = useRef<HTMLInputElement>(null)

  const [searchParams, setSearchParams] = useSearchParams()
 
  const handleKeyDown=(event: React.KeyboardEvent<HTMLInputElement> )=>{

    if(event.key === 'Enter'){
      const value = inputRef.current?.value ?? ''
      
      setSearchParams(prev=>{
        prev.set('name', value)
        return prev
      })
    }
  }
  return (
    <>
    
    <div className="flex flex-col lg:flex-row gap-4 mb-8">
          {/* Search */}
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input placeholder="Search heroes, villains, powers, teams..." className="pl-12 h-12 text-lg" 
              ref={inputRef}
              onKeyDown={handleKeyDown}
              defaultValue={searchParams.get('name') ?? ''}
              />
          </div>

          {/* Action buttons */}
          <div className="flex gap-2">
            <Button variant="outline" className="h-12 bg-transparent">
              <Filter className="h-4 w-4 mr-2" />
              Filters
            </Button>

            <Button variant="outline" className="h-12 bg-transparent">
              <SortAsc className="h-4 w-4 mr-2" />
              Sort by Name
            </Button>

            <Button variant="outline" className="h-12 bg-transparent">
              <Grid className="h-4 w-4" />
            </Button>

            <Button className="h-12">
              <Plus className="h-4 w-4 mr-2" />
              Add Character
            </Button>
          </div>
        </div>

        <Accordion type="single" collapsible>
          <AccordionItem value="item-1">
           <AccordionTrigger>Filtros Avanzados</AccordionTrigger>
              <AccordionContent>
          <div className="bg-white rounded-lg p-6 mb-8 shadow-sm border">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-lg font-semibold">Advanced Filters</h3>
            <Button variant="ghost">Clear All</Button>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Team</label>
              <div className="h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm">
                All teams
              </div>
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium">Category</label>
              <div className="h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm">
                All categories
              </div>
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium">Universe</label>
              <div className="h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm">
                All universes
              </div>
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium">Status</label>
              <div className="h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm">
                All statuses
              </div>
            </div>
               <div className="mt-4">
              <Slider defaultValue={[33]} max={100} step={1} />
          </div>
          </div>
          </div>
              </AccordionContent>
          </AccordionItem>
        </Accordion>      
    </>
  )
}
~~~

- Pero vamos a hacer que se despliegue a través del botón de filtros mediante un query parameter
- Quito el Trigger y pongo en el value item-1

~~~js
<Accordion type="single" collapsible value='item-1'>
    <AccordionItem value="item-1">
    {/*<AccordionTrigger>Filtros Avanzados</AccordionTrigger>*/}
        <AccordionContent> 
        {...code}
~~~

- Ahora no se ve nada, hagamos que con el botón Filter se muestren los filtros

### Filtros avanzados

- Quiero jugar con los valores del slider y de los filtros en la URL
- SearchControls.tsx

~~~js
const activeAccordion = searchParams.get('active-accordion') ?? ''

{...code}

 <Accordion type="single" collapsible value={activeAccordion}>
          <AccordionItem value="advanced-filters">
~~~

- Ahora en el botón de Filters debo usar el onClick para cambiar el activeAccordion

~~~js
    //función de handle
const setQueryParams = (name: string, value: string)=>{
        setSearchParams(prev=>{
        prev.set(name, value)
        return prev
      })
  }

const handleKeyDown=(event: React.KeyboardEvent<HTMLInputElement> )=>{

    if(event.key === 'Enter'){
      const value = inputRef.current?.value ?? ''
      setQueryParams('name', value)
    }
  }
  {...code}

  {/* Action buttons */}
    <div className="flex gap-2">
    <Button variant="outline" className="h-12 bg-transparent"
        onClick={()=>setQueryParams('active-accordion', 'advanced-filters')}
    >
        <Filter className="h-4 w-4 mr-2" />
        Filters
    </Button>

    {...code}
~~~

- De esta manera se despliega si le doy al botón Filters, pero lo que necesito es un toggle, para que cuando vuelva a darle al botón se cierren los filtros
- Cambio el color si el Filter está activo

~~~js
<Button variant={activeAccordion === 'advanced-filters' ? 'default': 'outline'} 
    className="h-12"
    onClick={()=>setQueryParams('active-accordion', 'advanced-filters')}
    >
    <Filter className="h-4 w-4 mr-2" />
    Filters
</Button>
~~~

- Hacemos el toggle

~~~js
<Button variant={activeAccordion === 'advanced-filters' ? 'default': 'outline'} 
    className="h-12"
    onClick={()=>{
    if(activeAccordion === 'advanced-filters'){
        setQueryParams('active-accordion','')
        return
    }
    setQueryParams('active-accordion','advanced-filters')
    }}  
>
    <Filter className="h-4 w-4 mr-2" />
    Filters
</Button>
~~~

- Vayamos con el Strength

~~~js
const selectedStrength = Number(searchParams.get('strength') ?? '0')

{...code}

</div>
    <div className="mt-4">
    <label className="text-sm font-medium">
        Minimum Strength: {selectedStrength}
    </label>
    <Slider defaultValue={[selectedStrength]} 
    max={10} 
    step={1} 
    onValueChange={value=> setQueryParams('strength', value[0].toString())}
    />
</div>
~~~

- En SearchPage mandamos el strength en el useQuery

~~~js
const SearchPage = () => {

  const [searchParams] = useSearchParams()

  const name = searchParams.get('name') ?? undefined
  const strength = searchParams.get('strength') ?? undefined

  const {data:heroes = []} = useQuery({
    queryKey: ['search', {name, strength}],
    queryFn: ()=> searchHeroAction({name, strength}),
    staleTime: 1000 * 60 * 5
  })

  {...code}
}
~~~

