# REACT HERRERA 2025

## Primeros pasos

> npm create vite

- Selecciono React y TypeScript+SWC (Speedy Web Compiler)
- Cuando uso .map hago el return implícito con paréntesis ()
- Desestructuro las propiedades
- Debo usar un key único

~~~js
import { ItemCounter } from './shopping-cart/ItemCounter';

interface ItemInCart {
  productName: string;
  quantity: number;
}

const itemsInCart: ItemInCart[] = [
  { productName: 'Nintendo Switch 2', quantity: 1 },
  { productName: 'Pro Controller', quantity: 2 },
  { productName: 'Super Smash', quantity: 5 },
];

export function FirstStepsApp() {
  return (
    <>
      <h1>Carrito de compras</h1>

      {itemsInCart.map(({ productName, quantity }) => (
        <ItemCounter key={productName} name={productName} quantity={quantity} />
      ))}

      {/* <ItemCounter name="Nintendo Switch 2" quantity={1} />
      <ItemCounter name="Pro Controller" quantity={2} />
      <ItemCounter name="Super Smash" quantity={3} />
      <ItemCounter name="Super Mario" quantity={3} /> */}
    </>
  );
}
~~~

- Para añadir propiedades uso la interface, la llamo Props
- Si quiero usar styles, debo llamar al css .module.css
- Puedo usar corchetes si la clase de css está separada por un guión

~~~js
import { useState } from 'react';

// import './ItemCounter.css';
import styles from './ItemCounter.module.css'; //debe llevar .module.css

interface Props {
  name: string;
  quantity?: number;
}

export const ItemCounter = ({ name, quantity = 1 }: Props) => {
  const [count, setCount] = useState(quantity);

  const handleAdd = () => {
    setCount(count + 1);
  };

  const handleSubtract = () => {
    if (count === 1) return; //1 es el mínimo

    setCount(count - 1);
  };

  return (
    <section
      className={styles.itemRow}
      // style={{
      //   display: 'flex',
      //   alignItems: 'center',
      //   gap: 10,
      //   marginTop: 10,
      // }}
    >
      <span
        className={styles['item-text']} //uso corchetes
        style={{
          color: count === 1 ? 'red' : 'black',
        }}
      >
        {name}
      </span>
      <button onClick={handleAdd}>+1</button>
      <span>{count}</span>
      <button onClick={handleSubtract}>-1</button>
    </section>
  );
};
~~~

- Hice también MyAwesomeApp para ver como imprimir variables y el renderizado condicional con isActive

~~~js
import { CSSProperties } from 'react';

const firstName = 'Fernando';
const lastName = 'Herrera';

const favoriteGames = ['Elden Ring', 'Smash', 'Metal Gear'];
const isActive = false;

const address = {
  zipCode: 'ABC-123',
  country: 'Canadá',
};

const myStyles: CSSProperties = {
  backgroundColor: '#fafafa',
  borderRadius: 20,
  padding: 10,
  marginTop: 30,
};

export const MyAwesomeApp = () => {
  return (
    <>
      <h1>{firstName}</h1>
      <h3>{lastName}</h3>

      <p>{favoriteGames.join(', ')}</p>
      <p>{2 + 2}</p>

      <h1>{isActive ? 'Activo' : 'No activo'}</h1>

      <p style={myStyles}>{JSON.stringify(address)}</p>
    </>
  );
};
~~~

- El main

~~~js
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { FirstStepsApp } from './FirstStepsApp';
import { MyAwesomeApp } from './MyAwesomeApp';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <FirstStepsApp />
    {/* <MyAwesomeApp /> */}
  </StrictMode>
);
~~~

## Testing

### Configuración Vitest

> npm install -D vitest

- Creo el script en el package.json

~~~json
{
    "test":"vitest",
    "test:ui": "vitest --ui",
    "coverage": "vitest run --coverage"
}
~~~

### Primeras pruebas

- Creo la carpeta src/helpers/math.helper.ts para hacer la introducción a las pruebas
- math.helper.ts

~~~js
export const add=(a:number, b:number)=>{
    return a+b
}
export const subtract=(a:number, b:number)=>{
    return a-b
}
export const multiply=(a:number, b:number)=>{
    return a*b
}
export const divide=(a:number, b:number)=>{
    return a/b
}
~~~

- Creo src/tests
- Una aproximación sería seguir dentro de tests la misma estructura de carpetas de src
- tests/helpers/math.test.ts, etc
- Si la aplicación está acabada es viable, pero si voy a tener que ir moviendo cosas es un rollo
- Otra aproximación es crear el test en el mismo nivel donde está el archivo a testar
- Usaremos esta aproximación
- src/helpers/math.test.tsx

~~~js
import {expect, test} from 'vitest'
import { add } from './math.helper'

test('should add two positive numbers', ()=>{
    //Arrange
    const a= 1
    const b= 1
    
    //Act
    const result = add(a,b)

    //Assert
    expect(result).toBe(2)
})
~~~

### Agrupar pruebas

- Para agrupar uso describe

~~~js
import {describe, expect, test} from 'vitest'
import { add } from './math.helper'


describe("add", ()=>{

    test('should add two positive numbers', ()=>{
    
        const a= 1
        const b=1
    
        const result = add(a,b)
    
        expect(result).toBe(a+b)
    })
})
~~~

- Puedo tener un describe dentro de otro describe
- Hago el test a subtract

~~~js
describe("subtract", ()=>{
    test("should subtract two positive numbers", ()=>{
        const a=6
        const b=2

        const result = subtract(a,b)

        expect(result).toBe(a-b)
    })
})
~~~

### Pruebas sobre componentes de React

- Probemos MyAwesomeApp
- Para analizar las variables que no están siendo exportadas, debo mirar el punto dónde están utilizando
- Por ejemplo, firstName y lastName no están siendo exportadas pero se están utilizando en MyAwesomeApp que si está siendo exportado
- Entonces deberemos montar el componente en algún lugar, mirar lo que renderiza, y comprobar si tenemos el nombre y el apellido
- Otra cosa a evaluar es su comportamiento, qué pasa si aprieto un botón
- Empecemos por montar el componente en el test
- **Para evaluar componentes instalo testing library**

> npm i -D @testing-library/react @testing-library/dom @types/react @types/react-dom

- En vite.config debo importar **defineConfig** de vitest/config

~~~js
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react-swc'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  test:{
    environment: 'jsdom',
    globals: true
  }
})
~~~

- Si tengo vitest corriendo, cancelo y vuelvo a poner a andar. Me preguntará para instalar jsdom
- Lo instalo 
- Uso render para montar el componente
- Puedo desestructurar un montón de cosas, desestructuro container
- Puedo imprimir en consola el html del componente
- MyAwesomeApp.test.tsx

~~~js
import { render } from "@testing-library/react";
import { describe, test } from "vitest";
import { MyAwesomeApp } from "./MyAwesomeApp";

describe("MyAwesomeApp", ()=>{

    test('should render firstName and lastName', ()=>{
        
        const {container}= render(<MyAwesomeApp />)
        console.log(container.innerHTML)
    })
})
~~~

- Se suele usar el screen que es más amigable para trabajar el resultado de la renderización de mi componente

~~~js
import { render, screen } from "@testing-library/react";
import { describe, test } from "vitest";
import { MyAwesomeApp } from "./MyAwesomeApp";

describe("MyAwesomeApp", ()=>{

    test('should render firstName and lastName', ()=>{
        
        render(<MyAwesomeApp />)
        console.log(screen)
    })
})
~~~

- Este screen tiene un método bien interesante que es el debug

~~~js
import { render, screen } from "@testing-library/react";
import { describe, test } from "vitest";
import { MyAwesomeApp } from "./MyAwesomeApp";

describe("MyAwesomeApp", ()=>{

    test('should render firstName and lastName', ()=>{
        
        render(<MyAwesomeApp />)
        screen.debug()
    })
})
~~~

- Así se ve en consola el componente mucho mejor (no hace falta el console.log)

### Buscar elementos en el componente renderizado

- El container de la desestructuración del componente es un HTMLElement
- A veces el container será más fácil de usar, a veces el screen
- Para seleccionar el h1 uso querySelector, me selecciona el primero que encuentre (hay dos)
- Uso .innerHTML para ver el contenido del h1

~~~js
import { render, screen } from "@testing-library/react";
import { describe, test } from "vitest";
import { MyAwesomeApp } from "./MyAwesomeApp";

describe("MyAwesomeApp", ()=>{

    test('should render firstName and lastName', ()=>{
        
        const {container}= render(<MyAwesomeApp />)
        //screen.debug()

        const h1= container.querySelector('h1') //regresa el primer h1 que encuentre
        console.log(h1?.innerHTML)
    })
})
~~~

- Uso expect

~~~js
expect(h1?.innerHTML).toBe('Fernando')
~~~

- Si hay espacios en la etiqueta también los detecta

~~~js
<h1> {firstName} </h1> //Esto devuelve " Fernando " con espacios
~~~

- Puedo salvar este fallo usando .toContain (que contenga)

~~~js
expect(h1?.innerHTML).toContain('Fernando')
~~~

- Puedo evaluar también el h3 con lastName

~~~js
import { render, screen } from "@testing-library/react";
import { describe, expect, test } from "vitest";
import { MyAwesomeApp } from "./MyAwesomeApp";

describe("MyAwesomeApp", ()=>{

    test('should render firstName and lastName', ()=>{
        
        const {container}= render(<MyAwesomeApp />)
        //screen.debug()

        const h1= container.querySelector('h1') //regresa el primer h1 que encuentre

        const h3 = container.querySelector('h3')

        expect(h1?.innerHTML).toContain('Fernando')
        expect(h3?.innerHTML).toContain('Herrera')
    })
})
~~~

- Puedo poner todos los expects que quiera
- Solo pasa la prueba si todos los expects pasan la prueba
- El screen es útil porque permite actualizarse basado en los cambios y disparo de eventos
- Cuando algo suceda en el componente, el container de la desestructuración no va a estar actualizado
- Usemos el screen

~~~js
import { render, screen } from "@testing-library/react";
import { describe, expect, test } from "vitest";
import { MyAwesomeApp } from "./MyAwesomeApp";

describe("MyAwesomeApp", ()=>{

    test('should render firstName and lastName', ()=>{
        
        const {container}= render(<MyAwesomeApp />)
        //screen.debug()

        const h1= container.querySelector('h1') //regresa el primer h1 que encuentre

        const h3 = container.querySelector('h3')

        expect(h1?.innerHTML).toContain('Fernando')
        expect(h3?.innerHTML).toContain('Herrera')
    })
    test('should render firstName and lastName', ()=>{
        
        render(<MyAwesomeApp />)
        screen.debug()

        const h1 = screen.getByRole('heading', {
            level: 1 //le indico el nivel
        })

        console.log(h1?.innerHTML)
    })
})
~~~

- Esto da error porque hay 2 h1 en el heading (el primer div)
- Lo puedo solucionar poniéndole un id

~~~jsx
export const MyAwesomeApp = () => {
  return (
    <>
      <h1 data-testid="first-name-title">{firstName}</h1>
  
  {...code}
  )}

~~~

- Lo selecciono con .getByTestId

~~~js
test('should render firstName and lastName', ()=>{
    
    render(<MyAwesomeApp />)
    screen.debug()

    const h1 = screen.getByTestId('first-name-title')

    expect(h1.innerHTML).toContain('Fernando')
})
~~~

- Esto no es lo recomendado pero es una manera bien limpia de hacerlo
- De esta manera no evalúo que es un h1 o un heading
- *NOTA*: Si es un render inicial usar container. Pero si hay eventos, obligatoriamente se va a tener que usar screen

### Evaluar snapshots

- Hay veces que nos va a interesar evaluar que el html luce de una manera en específico
- Para ello creo un snapshot

~~~js
test('should match snapshot', ()=>{

    const {container} = render(<MyAwesomeApp />)

    expect(container).toMatchSnapshot()

})
~~~

- Cuando ejecuto este test aparece una carpeta en mi src/ llamada snapshots

~~~jsx
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`MyAwesomeApp > should match snapshot 1`] = `
<div>
  <h1
    data-testid="first-name-title"
  >
    Fernando
  </h1>
  <h3>
     
    Herrera
     
  </h3>
  <p>
    Elden Ring, Smash, Metal Gear
  </p>
  <p>
    4
  </p>
  <h1>
    No activo
  </h1>
  <p
    style="background-color: rgb(250, 250, 250); border-radius: 20px; padding: 10px; margin-top: 30px;"
  >
    {"zipCode":"ABC-123","country":"Canadá"}
  </p>
</div>
`;
~~~

- Si cambio algo del componente MyAwesomeApp.tsx el test falla
- Puedo presionar u en consola para actualizar el snapshot
- Hagámoslo con el screen
- Añado un testId al div principal (no es muy buena idea, ahora lo explicaré)

~~~jsx
export const MyAwesomeApp = () => {
  return (
    <div data-testid="div-app">
      <h1 data-testid="first-name-title">{firstName}</h1>
      <h3> {lastName} </h3>

      <p>{favoriteGames.join(', ')}</p>
      <p>{2 + 2}</p>

      <h1>{isActive ? 'Activo' : 'No activo'}</h1>

      <p style={myStyles}>{JSON.stringify(address)}</p>
    </div>
  );
};
~~~

- En el test

~~~js
 test('should match snapshot - screen', ()=>{

    render(<MyAwesomeApp />)

    expect(screen.getByTestId('div-app')).toMatchSnapshot()

})
~~~

- Apreto u para actualizar el cambio en el snapshot que hice en el div principal
- Ahora tengo 2 snapshots en el archivo snapshots/MyAwesomeApp.test.tsx.snap
- **¿Porqué no es buena idea los testId?**
  - Son muy volátiles, alguien puede borrarlos por considerarlos innecesarios
  - A veces pueden ser una solución rápida y fácil
  - Usaremos los snapshots con container por ser más fácil
  - Solo usaremos snapshots si el componente no va a cambiar

### Pruebas en el componente ItemCounter

- ItemCounter.tsx

~~~jsx
import { useState } from 'react';

// import './ItemCounter.css';
import styles from './ItemCounter.module.css';

interface Props {
  name: string;
  quantity?: number;
}

export const ItemCounter = ({ name, quantity = 1 }: Props) => {
  const [count, setCount] = useState(quantity);

  const handleAdd = () => {
    setCount(count + 1);
  };

  const handleSubtract = () => {
    if (count === 1) return;

    setCount(count - 1);
  };

  return (
    <section
      className={styles.itemRow}
      // style={{
      //   display: 'flex',
      //   alignItems: 'center',
      //   gap: 10,
      //   marginTop: 10,
      // }}
    >
      <span
        className={styles['item-text']}
        style={{
          color: count === 1 ? 'red' : 'black',
        }}
      >
        {name}
      </span>
      <button onClick={handleAdd}>+1</button>
      <span>{count}</span>
      <button onClick={handleSubtract}>-1</button>
    </section>
  );
};
~~~

- Para probar el ItemCounter que hay en FirstStepsApp hay que crear su propio archivo de test 
- Si probáramos como interactúa sería una prueba de integración
- Empecemos probando lo más fácil (menos acoplado) y pequeño
- Entonces vamos al ItemCounter
- Tenemos eventos que se disparan (onClick), valores que se renderizan (count)

~~~js
import { render, screen } from "@testing-library/react";
import { describe, test } from "vitest";
import { ItemCounter } from "./shopping-cart/ItemCounter";

describe('ItemCounter', ()=>{

    test('should render with default values', ()=>{
        render(<ItemCounter name="Test Item" />)

        screen.debug()
    })
})
~~~

- Si observo el html en consola, las clases tienen un hash que es volátil, no hay que analizarlo
- Busquemos el span que tiene "Test Item"

~~~js
import { render, screen } from "@testing-library/react";
import { describe, expect, test } from "vitest";
import { ItemCounter } from "./shopping-cart/ItemCounter";

describe('ItemCounter', ()=>{

    test('should render with default values', ()=>{

        const name= "Test Item"

        render(<ItemCounter name={name} />)

        expect(screen.getByText(name)).toBeDefined() //o .not.toBeNull()
    })
})
~~~

- Probemos que renderice la quantity

~~~js
 test('should render with custom quantity', ()=>{

    const name= "Pepe"
    const quantity=10

    render(<ItemCounter name={name} quantity={quantity} />)

    expect(screen.getByText(quantity)).toBeDefined() //o .not.toBeNull()
})
~~~

### Disparar eventos

- Empecemos por el botón de +1
- Evaluamos que el count sume 1, no si el useState funciona
- El primer botón en el html es el de + y el segundo es el de -
- Podría usar un testId, pero voy a barrer todos los botones (2) y desestructurarlos posicionalmente al ser un arreglo
- Para disparar un evento uso fireEvent

~~~jsx
test('should increase count when +1 button is pressed', ()=>{

    render(<ItemCounter name={"Test Item"} quantity={1} />)

    const [buttonAdd, buttonSubtract]= screen.getAllByRole('button')

    fireEvent.click(buttonAdd) //disparo el evento click al button +1

    expect(screen.getByText('2')).toBeDefined() //debería encontrar un 2 

})
~~~

- Usar el getByText de esta manera hace la prueba muy volátil
- Sería más adecuado usar una clase para el span que renderiza la quantity y hacer el expect. Pero esto es lo más sencillo
- Hago lo mismo con subtract

~~~js
test('should decrease count when -1 button is pressed', ()=>{

    render(<ItemCounter name={"Test Item"} quantity={2} />)

    const [buttonAdd, buttonSubtract]= screen.getAllByRole('button')

    fireEvent.click(buttonSubtract)

    expect(screen.getByText('1')).toBeDefined()

})
~~~

### Comprobar estilos

- En el span del counter pusimos una condición de que si el contador es 1 sea red y si no black con un ternario

~~~jsx
<span
    className={styles['item-text']}
    style={{
      color: count === 1 ? 'red' : 'black',
    }}
  >
    {name}
</span>
~~~

- Lo que vamos a evaluar es el producto cuando count es 1 ('red')
- Podemos tomar el span por el name, que en este caso es Test Item
- Es un elemento HTML por lo que tiene los métodos y las clases de un elemento HTML
- Si quiero evaluar el estilo uso .style, color es la propiedad que yo escribí

~~~js
test('should change to red when count is 1', ()=>{

    const name="Test Item"
    const quantity=1
    render(<ItemCounter name={name} quantity={quantity} />)

    const itemText = screen.getByText(name)

    expect(itemText.style.color).toBe('red')

})
~~~

- Hago lo mismo para cuando debe ser en negro

~~~js
test('should be black when count is greater than 1', ()=>{

    const name="Test Item"
    const quantity=2
    render(<ItemCounter name={name} quantity={quantity} />)

    const itemText = screen.getByText(name)

    expect(itemText.style.color).toBe('black')

})
~~~

### Prueba en FirstStepApp

- Lo que hay que evaluar aquí es que en el .map se pueda mostrar el componente ItemCounter y que reciba los argumentos que espera

- FirstStepsApp.tsx

~~~jsx
import { ItemCounter } from './shopping-cart/ItemCounter';

interface ItemInCart {
  productName: string;
  quantity: number;
}

const itemsInCart: ItemInCart[] = [
  { productName: 'Nintendo Switch 2', quantity: 1 },
  { productName: 'Pro Controller', quantity: 2 },
  { productName: 'Super Smash', quantity: 5 },
];

export function FirstStepsApp() {
  return (
    <>
      <h1>Carrito de compras</h1>

      {itemsInCart.map(({ productName, quantity }) => (
        <ItemCounter key={productName} name={productName} quantity={quantity} />
      ))}

      {/* <ItemCounter name="Nintendo Switch 2" quantity={1} />
      <ItemCounter name="Pro Controller" quantity={2} />
      <ItemCounter name="Super Smash" quantity={3} />
      <ItemCounter name="Super Mario" quantity={3} /> */}
    </>
  );
}
~~~

- Comparamos con el snapshot

~~~js
import { fireEvent, render, screen } from "@testing-library/react";
import { describe, expect, test } from "vitest";
import { ItemCounter } from "./shopping-cart/ItemCounter";
import { FirstStepsApp } from "./FirstStepsApp";

describe('FirstStepsApp', ()=>{
    
    test('should match snapshot', ()=>{

        const {container}= render(<FirstStepsApp />)

        expect(container).toMatchSnapshot()
    })

})
~~~

### Componentes ficticios - Mock Components

- Queremos asegurarnos de que el componente itemsInCart.map sea llamado con la info deseada sin renderizarlo
- Generaremos un mock de este componente, porque en la vida real, este componente podría llamar a otro y otro, un context fuera...
- En lugar de renderizar el componente y contar los spans generados, voy a hacer un mock de este ItemCounter
- Con este mock puedo alterar una dependencia externa como es el ItemCounter desde FirstStepsApp

~~~js
import { fireEvent, render, screen } from "@testing-library/react";
import { describe, expect, test, vi } from "vitest";
import { ItemCounter } from "./shopping-cart/ItemCounter";
import { FirstStepsApp } from "./FirstStepsApp";


vi.mock("./shopping-cart/ItemCounter", ()=>({
    ItemCounter: ()=> <div data-testid="ItemCounter" />
}))


describe('FirstStepsApp', ()=>{

    test('should match snapshot', ()=>{

        const {container}= render(<FirstStepsApp />)

        expect(container).toMatchSnapshot()
    })

    test("should render the correct nuber of ItemCounter Components", ()=>{
        render(<FirstStepsApp />)

        screen.debug()
    })

})
~~~

- Falla el snapshot y veo que renderiza tres divs con el data-testid "ItemCounter"
  - Presiono u para actualizar la snapshot
- Renderiza tres porque tengo tres elementos en el array itemsInCart
- Uso el getAllByTestId para barrerlos todos, deben de ser 3

~~~js
test("should render the correct nuber of ItemCounter Components", ()=>{
    render(<FirstStepsApp />)

    const itemCounters = screen.getAllByTestId("ItemCounter")

    expect(itemCounters.length).toBe(3)
})
~~~

- ¿Qué más podemos evaluar?
- Tenemos que asegurarnos de que el name y la quantity sean proporcionadas al ItemCounter

### Esperar argumentos específicos

- Este ItemCounter mock también recibe sus propiedades
- Uso fn para crear una función ficticia
- Me dirá con qué argumentos fue llamada, yo puedo simular retornos

~~~js
const mockItemCounter = vi.fn((props: unknown)=>{
    return  <div data-testId="ItemCounter" />
})

vi.mock("./shopping-cart/ItemCounter", ()=>({
    ItemCounter: (props: unknown)=>mockItemCounter(props)    
}))
~~~

- En el mock, como le paso las props uso una función de flecha
- Notar el retorno implícito del callback con ()
- Ahora haremos otra prueba para comprobar que le pasa las properties correctas

~~~js
test('should render ItemCounter with correct props', ()=>{
    render(<FirstStepsApp />)

    expect(mockItemCounter).toHaveBeenCalledTimes(3)
})
~~~

- Este test falla porque dice que se renderizó 9 veces (3+3+3), porque cuenta las otras pruebas
- Con lo cual tenemos que resetear el renderizado en cada prueba, usando afterEach con **vi.clearAllMocks**

~~~js
import { fireEvent, render, screen } from "@testing-library/react";
import { afterEach, describe, expect, test, vi } from "vitest";
import { ItemCounter } from "./shopping-cart/ItemCounter";
import { FirstStepsApp } from "./FirstStepsApp";


const mockItemCounter = vi.fn((props: unknown)=>{
    return  <div data-testId="ItemCounter" />
})

vi.mock("./shopping-cart/ItemCounter", ()=>({
    ItemCounter: (props: unknown)=>mockItemCounter(props)    
}))


describe('FirstStepsApp', ()=>{

    afterEach(()=>{
        vi.clearAllMocks()
    })

    test('should match snapshot', ()=>{

        const {container}= render(<FirstStepsApp />)

        expect(container).toMatchSnapshot()
    })

    test("should render the correct number of ItemCounter Components", ()=>{
        render(<FirstStepsApp />)

        const itemCounters = screen.getAllByTestId("ItemCounter")

        expect(itemCounters.length).toBe(3)
    })

    test('should render ItemCounter with correct props', ()=>{
        render(<FirstStepsApp />)

        expect(mockItemCounter).toHaveBeenCalledTimes(3)
    })

})
~~~

- Falta evaluar que se llamen con las properties

~~~js
test('should render ItemCounter with correct props', ()=>{
    render(<FirstStepsApp />)

    expect(mockItemCounter).toHaveBeenCalledTimes(3)
    expect(mockItemCounter).toHaveBeenCalledWith(
          { name: 'Nintendo Switch 2', quantity: 1 },
    )
    expect(mockItemCounter).toHaveBeenCalledWith(
          { name: 'Pro Controller', quantity: 2 },
    )
    expect(mockItemCounter).toHaveBeenCalledWith(
          { name: 'Super Smash', quantity: 5 },
    )
})
~~~

### Índice de cobertura

- Para el coverage debo crear el script en el package.json

~~~json
 "coverage": "vitest run --coverage",
 "test:ui": "vitest --ui
~~~

- Cuando ejecuto los scripts me pide instalar unas dependencias, las instalo
