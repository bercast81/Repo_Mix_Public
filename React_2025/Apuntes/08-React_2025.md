## useContext

- Creo 09-useContext/ProfessionalApp.tsx

~~~js
import React from 'react'

export const ProfessionalApp = () => {
  return (
    <div className="bg-gradient flex flex-col-4 gap-4">
        <h1 className="text-2xl text-white">Professional App</h1>
    </div>
  )
}
~~~

- Lo renderizo en el main, dejo el Toaster en el main
- Creo otros directorios en 09-useCOntext   /data , /pages ,
- En creo pages/about/AboutPage.tsx
- También creo  /pages/auth/LoginPage.tsx
- También creo /pages/profile/ProfilePage.tsx 
- Vamos a hacer un SPA. La idea del SPA es que pueda poner en la url /about e ir a la página AboutPage, /login a LoginPage, etc
- Creo la carpeta /router/app.router.tsx

### React Router - Manejo de rutas

- Como dice en la documentación, tenemos tres formas de trabajar con React Router
    - Framework (adecuada para renderizar del lado del servidor)
    - Data (SPA, Single Page Application)
    - Declarativa (SPA)
- Vite pregunta si queremos instalar React Router y automatizar la instalación, lo cual es conveniente
- Data tiene muchas más funcionalidades que Declarativa
- Usaremos la forma Data
- Instalo

> npm i react-router

- En la documentación nos piden que creemos este objeto
- app.router.tsx

~~~js
import { RouterProvider } from "react-router/dom";

export const router = createBrowserRouter([
  {
    path: "/",
    element: <div>Hello World</div>,
  },
]);
~~~

- En lugar de montarlo en el main, lo monto en el segundo punto más alto de la aplicación, ProfessionalApp.tsx

~~~js
import React from 'react'
import { RouterProvider } from 'react-router'
import { appRouter } from './router/app.router'


export const ProfessionalApp = () => {
  return (
    <div className="bg-gradient">
        <RouterProvider router={appRouter} />
    </div>
  )
}
~~~

- Monto los componentes en el router con los paths
- Creo una página usando el comodín * para que vaya ahí cuando haya una ruta ererónea y no de error 
- Con Navigate redirecciono

~~~js
import { createBrowserRouter, Navigate } from "react-router";
import { AboutPage } from "../pages/about/AboutPage";
import { LoginPage } from "../pages/auth/LoginPage";
import { ProfilePage } from "../pages/profile/ProfilePage";


export const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AboutPage />,
  },
  {
    path: "/login",
    element: <LoginPage />,
  },
  {
    path: "/profile",
    element: <ProfilePage />,
  },
  {
    path: "*",
    element: <Navigate to='/' />,
  },
]);
~~~

### Navegar entre pantallas - Diseño de páginas

- Podemos hacer la navegación mediante componentes que disparen la navegación y mediante código
- Aprenderemos las dos
- AboutPage.tsx

~~~js

export const AboutPage = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Página sobre mi</h1>
      <div className="flex flex-col gap-2">
        <a href="/login">Iniciar sesión</a>
        <a href="/profile">Profile</a>
      </div>
    </div>
  )
}
~~~

- En lugar de usar anchor tags usaremos **Link** para mejor experiencia de usuario y no recargue el navegador cada vez que cambio de pantalla
- Les añado unos estilos

~~~js
import { Link } from "react-router"

export const AboutPage = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Página sobre mi</h1>
      <div className="flex flex-col gap-2">
        <Link to="/login" className="hover:text-blue-500 underline text-2xl">Iniciar sesión</Link>
        <Link to="/profile" className="hover:text-blue-500 underline text-2xl">Profile</Link>
      </div>
    </div>
  )
}
~~~

- En LoginPage uso los componentes Input y Button de shadcn
- El form no tiene un action de momento
- El button será de tipo submit

~~~js
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Link } from "react-router"

export const LoginPage = () => {
  return (
    <div className="flex flex-col min-h-screen">
      <h1 className="text-4xl font-bold">Iniciar sesión</h1>
      <hr />

      <form className="flex flex-col gap-2 my-10">
        <Input type='number' placeholder="ID del usuario"/>
        <Button type="submit">
          Login
        </Button>
      </form>

      <Link to="/">Volver a la página principal</Link>

    </div>
  )
}
~~~

- Puedo colocar dentro del Link un Button de shadcn

~~~js
<Link to="/">
   <Button variant="ghost">Volver a la página principal</Button>
</Link>
~~~

- Si sitúo el cursor encima del Button y apreto Ctrl+click me lleva a la definición del componente de shadcn
- Puedo modificar la linea de tailwind del componente
- Le añado cursor-pointer

~~~js
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
                //AQUI!!
  "inline-flex cursor-pointer items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
~~~

- Esto me cambia el icono del cursor por una manita cuando hago hover
- Falta el ProfilePage
- Renderizaremos un objeto en pantalla, por eso el JSON.stringify (todavía no hay objeto)
- El botón de Salir no tiene funcionalidad todavía

~~~js
import { Button } from "@/components/ui/button"

export const ProfilePage = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Profile Page</h1>
      <hr />

    <pre className="my-4">{JSON.stringify({}, null, 2)}</pre>

    <Button variant="destructive">Salir</Button>

    </div>
  )
}
~~~

## NOTA: Es importante usar un logger como Pino en lugar de console.log, porque bloquea el event loop de node

- Para configurar pino instalar con npm

> npm i pino

- src/logger/logger-pino.ts

~~~js
import pino from 'pino'
import type{ LoggerOptions, Logger } from "pino";

const options: LoggerOptions = {
  browser: {
    asObject: true, // logs como objetos en el navegador
  },
  level: import.meta.env.MODE === "development" ? "debug" : "info",
};

const logger: Logger = pino(options);

export default logger;
~~~

- Para usarlo solo importa logger

~~~js
import { Button } from "@/components/ui/button"
import logger from "@/logger/logger"

export const ProfilePage = () => {
  
  logger.info('Profile') //<--AQUI!!!

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Profile Page</h1>
      <hr />

    <pre className="my-4">{JSON.stringify({}, null, 2)}</pre>

    <Button variant="destructive">Salir</Button>

    </div>
  )
}
~~~

- Ya puedes ver los logs en la consola del navegador

### Contextos y proveedores en React

- La app solo debería mostrar el perfil si tenemos una sesión activa, y el link de Inicio de sesión debería de decir cerrar sesión
- En el perfil debería mostrar la info del usuario de la sesión iniciada
- El Login solo debería poder verse si no tengo una sesión iniciada
- Para compartir información entre componentes hermanos, necesitamos incorporar el provider (del contexto) en un punto alto de la app
- Creo 09-useContext/context/UserContext.tsx
- El Children representa los elementos anidados de un componente

~~~js
import { useState } from "react"


export const UserContextProvider = ({children}: any) => {
  
    const [name, setName] = useState('Miguel')
  
  
    return (
        <>{children}</>
    )
}
~~~

- Para que esta pieza de state esté disponible en toda la aplicación la envuelvo en el provider

~~~js
import { RouterProvider } from 'react-router'
import { appRouter } from './router/app.router'
import { UserContextProvider } from './context/UserContext'


export const ProfessionalApp = () => {
  return (
    <UserContextProvider>
      <div className="bg-gradient">
        <RouterProvider router={appRouter} />
      </div>
    </UserContextProvider>
  )
}
~~~

- Ahora la pieza de state está disponible desde cualquier componente dentro de ProfessionalApp
- En el Provider no se coloca html (se puede hacer, por eso) sino solo información o acciones
- Si solo voy a recibir el children puedo tiparlo así

~~~js
import { useState, type PropsWithChildren } from "react"

export const UserContextProvider = ({children}: PropsWithChildren) => {  
    return (
    <>{children}</>
  )
}
~~~

- Si hubiera más propiedades debería hacer una interfaz 

~~~js
interface UserContextProps{
  children: React.ReactNode
  id: number
}
~~~

- También se puede usar FC

~~~js
import { useState, type PropsWithChildren } from "react"

export const UserContextProvider =FC<PropsWithChildren>({children}) => { 
    return (
    <>{children}</>
  )
}
~~~

- Se puede crear el contexto en un archivo a parte, pero por ahora lo haremos todo en el mismo archivo

### Contexto de usuario - Información global

- El Provider es un Higher Order Component, un componente que recibe hijos
- Podremos usar useContext para leer el contexto, pero en las últimas versiones de React se recomienda usar **use**
- use es más flexible

~~~js
import { useState, type PropsWithChildren } from "react"

type AuthStatus = 'checking' | 'authenticated' | 'not-authenticated' 


interface UserContextProps{
    //state
    authStatus: AuthStatus
    user: User | null
    //methods
    login: (userId: number)=> boolean
    logout: ()=> void
}

export const UserContextProvider = ({children}: PropsWithChildren) => {
  
    return (
    <>{children}</>
  )
}
~~~

- Copio la data de usuarios en otro archivo (un mock de usuarios)
- user-mock.data.ts

~~~js
export interface User {
  id: number;
  name: string;
  title: string;
  tags: string[];
  contact: Contact;
  about: string;
  experience: Experience[];
  stats: Stats;
  skills: string[];
}

interface Contact {
  email: string;
  phone: string;
  location: string;
  website: string;
  joined: string;
}

interface Experience {
  role: string;
  company: string;
  period: string;
  description: string;
}

interface Stats {
  projects: number;
  connections: number;
  reviews: number;
}

export const users: User[] = [
  {
    id: 1001,
    name: 'Ana García',
    title: 'Desarrolladora Frontend Principal',
    tags: ['React', 'TypeScript', 'Next.js'],
    contact: {
      email: 'ana.garcia@email.com',
      phone: '+1 (555) 987-6543',
      location: 'Nueva York, NY',
      website: 'anagarcia.dev',
      joined: 'Abril 2018',
    },
    about:
      'Desarrolladora frontend creativa con 6 años de experiencia creando interfaces web modernas. Entusiasta de los sistemas de diseño y optimización de rendimiento.',
    experience: [
      {
        role: 'Desarrolladora Frontend Principal',
        company: 'Laboratorios Creativos',
        period: '2020 - Presente',
        description:
          'Desarrollé bibliotecas de componentes y lideré rediseños de arquitectura frontend.',
      },
      {
        role: 'Desarrolladora Frontend',
        company: 'Webify',
        period: '2017 - 2020',
        description:
          'Construí sitios web responsivos y colaboré con equipos de UX.',
      },
    ],
    stats: {
      projects: 30,
      connections: 210,
      reviews: 4.8,
    },
    skills: ['JavaScript', 'React', 'TypeScript', 'Next.js', 'CSS', 'HTML'],
  },
]
~~~

- Tenemos que crear el contexto con createContext de "react" (no de "vm")
- Para no tener que inicializar las props del context en lugar de la primera opción hago la segunda

~~~js
type AuthStatus = 'checking' | 'authenticated' | 'not-authenticated' 

interface UserContextProps{
    //state
    authStatus: AuthStatus
    user: User | null
    //methods
    login: (userId: number)=> boolean
    logout: ()=> void
}

//Da error porque no le estoy pasando las propiedades de UserContextProps
export const UserContext = createContext<UserContextProps>({})

//Lo declaro así si no quiero poner valores iniciales
export const UserContext = createContext({} as UserContextProps)
~~~

- Hay dos maneras de pasar este contexto, una sería esta

~~~js
import { useState, createContext type PropsWithChildren } from "react"
import type { User } from "../data/user-mock.data"
import logger from "@/logger/logger"


type AuthStatus = 'checking' | 'authenticated' | 'not-authenticated' 


interface UserContextProps{
    //state
    authStatus: AuthStatus
    user: User | null
    //methods
    login: (userId: number)=> boolean
    logout: ()=> void
}

export const UserContext = createContext({} as UserContextProps)

export const UserContextProvider = ({children}: PropsWithChildren) => {
  
    const [authStatus, setAuthStatus] = useState<AuthStatus>('checking')
    const [user,setUser] = useState<User | null>(null)
    
    const handleLogin = (userId: number): boolean=>{
      logger.info('login')
       return true
    }
    
    const handleLogout = ()=>{
        logger.info('logout')
    }
    
    return (
        <UserContext value={{
            authStatus: authStatus,
            user: user,
            login: handleLogin,
            logout: handleLogout
        }}>
            {children}
        </UserContext>
  )
}
~~~

### Consumir el contexto

- Desarrollo el método handleLogin en el UserContext

~~~js
const handleLogin = (userId: number): boolean=>{
      
      const user = users.find(user=> user.id == userId)
      if(!user){
          logger.info('user not found')
          setUser(null)
          setAuthStatus('not-authenticated')
          return false
      }

      setUser(user)
      setAuthStatus('authenticated')
      return true
  }
  
  const handleLogout = ()=>{
      setAuthStatus('not-authenticated')
      setUser(null)
  }
~~~

- Ahora si voy a Login y le paso un ID veo que hay un refresh del navegador, hay que controlar eso
- Uso onSubmit, que es la manera tradicional. También se puede usar action
- Si coloco el cursor encima del evento me da el tipo (React.FormEvent-HTMLFormElementy)
- /pages/auth/LoginPage.tsx

~~~js
return (
    <div className="flex flex-col min-h-screen">
      <h1 className="text-4xl font-bold">Iniciar sesión</h1>
      <hr />

      <form className="flex flex-col gap-2 my-10"
        onSubmit={e=>handleSubmit(e)} //coloco el cursor aqui para ver el tipo
      >
        <Input type='number' placeholder="ID del usuario"/>
        <Button type="submit">
          Login
        </Button>
      </form>

      <Link to="/">
        <Button variant="ghost">Volver a la página principal</Button>
      </Link>

    </div>
  )
~~~

- Conecto el value del input con un state userId

~~~js
<Input type='number' placeholder="ID del usuario" value={userId} onChange={e=> setUserId(e.target.value)}/>
~~~

- Para leer el contexto hay dos maneras, con useContext apuntando al objeto UserContext (que crea el contexto)

~~~js
const {login} = useContext(UserContext)
~~~

- Le paso el userId, al ser un string lo parseo con + a número

~~~js
export const LoginPage = () => {

  const {login} = useContext(UserContext)
  const [userId, setUserId] =useState('')

  const handleSubmit = (event:  React.FormEvent<HTMLFormElement>)=>{
    event.preventDefault()
    const result = login(+userId)
    logger.info(result) //si todo va bien devuelve un true en la consola del navegador
  }

  return (
    <div className="flex flex-col min-h-screen">
      <h1 className="text-4xl font-bold">Iniciar sesión</h1>
      <hr />

      <form className="flex flex-col gap-2 my-10"
        onSubmit={e=>handleSubmit(e)}
      >
        <Input type='number' placeholder="ID del usuario" value={userId} onChange={e=> setUserId(e.target.value)}/>
        <Button type="submit">
          Login
        </Button>
      </form>

      <Link to="/">
        <Button variant="ghost">Volver a la página principal</Button>
      </Link>

    </div>
  )
}
~~~

- El UserContext.tsx está así

~~~js
import { useState, createContext, type PropsWithChildren } from "react"
import { users} from "../data/user-mock.data"
import type {User} from '../data/user-mock.data'
import logger from "@/logger/logger"


type AuthStatus = 'checking' | 'authenticated' | 'not-authenticated' 


interface UserContextProps{
    //state
    authStatus: AuthStatus
    user: User | null
    //methods
    login: (userId: number)=> boolean
    logout: ()=> void
}

export const UserContext = createContext({} as UserContextProps)

export const UserContextProvider = ({children}: PropsWithChildren) => {
  
    const [authStatus, setAuthStatus] = useState<AuthStatus>('checking')
    const [user,setUser] = useState<User | null>(null)
    
    const handleLogin = (userId: number): boolean=>{
        
        const user = users.find(user=> user.id == userId)
        if(!user){
            logger.info('user not found')
            setUser(null)
            setAuthStatus('not-authenticated')
            return false
        }

        setUser(user)
        setAuthStatus('authenticated')
        return true
    }
    
    const handleLogout = ()=>{
        setAuthStatus('not-authenticated')
        setUser(null)
    }
    
    return (
        <UserContext value={{
            authStatus: authStatus,
            user: user,
            login: handleLogin,
            logout: handleLogout
        }}>
            {children}
        </UserContext>
  )
}
~~~

- Si le paso un id válido en el input del LoginPage del navegador (como 1001) me devuelve un true por consola
- En las devTools, en Components, dentro del Context.Provider tengo en la pestaña props el authStatus: 'authenticated' y el user
- Si recargo el navegador web se pierde la info (vamos a tener que hacerlo persistente)
- Para que el authStatus al refrescar el navegador cambie de checking a non-authenticated vamos a usar un useEffect
- Si el resultado no es exitoso uso el Toast para mandar una notificación en pantalla
- Si el login es exitoso tenemos que hacer una navegación al Profile. Uso el useNavigate

~~~js
export const LoginPage = () => {

  const {login} = useContext(UserContext)
  const [userId, setUserId] =useState('')

  const navigation = useNavigate()

  const handleSubmit = (event:  React.FormEvent<HTMLFormElement>)=>{
    event.preventDefault()
    const result = login(+userId)
    logger.info(result)
    if(!result){
      toast.error('Usuario no encontrado')
      return
    }

    navigation('/profile')
  }
{...code}
}
~~~

- Debo desestructurar el state del user en el Profile usando el context para renderizarlo en pantalla
- /profile/ProfilePage.tsx

~~~js
import { UserContext } from "@/09-useContext/context/UserContext"
import { Button } from "@/components/ui/button"
import { useContext } from "react"

export const ProfilePage = () => {

  const {user} = useContext(UserContext)
  
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Profile Page</h1>
      <hr />

    <pre className="my-4">{JSON.stringify({user}, null, 2)}</pre>

    <Button variant="destructive">Salir</Button>

    </div>
  )
}
~~~

- También puedo usar el use

~~~js
const {user} = use(UserContext)
~~~

### Persistencia del usuario

- En el UserContext, dentro del handleLogin guardo el usuario en el localStorage

~~~js
const handleLogin = (userId: number): boolean=>{
        
        const user = users.find(user=> user.id == userId)
        if(!user){
            logger.info('user not found')
            setUser(null)
            setAuthStatus('not-authenticated')
            return false
        }

        setUser(user)
        setAuthStatus('authenticated')
        localStorage.setItem('userId', userId.toString()) //AQUI!

        return true
    }
~~~

- Ahora que tengo el userId en el localStorage, puedo montar un efecto que compruebe el id en el localStorage para cuando se monte el UserContext
- Lo pongo en el UserContext, no ocupamos ninguna dependencia
- Remuevo el userId del localstorage en el logout

~~~js
import { useState, createContext, type PropsWithChildren, useEffect } from "react"
import { users} from "../data/user-mock.data"
import type {User} from '../data/user-mock.data'
import logger from "@/logger/logger"


type AuthStatus = 'checking' | 'authenticated' | 'not-authenticated' 


interface UserContextProps{
    //state
    authStatus: AuthStatus
    user: User | null
    //methods
    login: (userId: number)=> boolean
    logout: ()=> void
}

export const UserContext = createContext({} as UserContextProps)

export const UserContextProvider = ({children}: PropsWithChildren) => {
  
    const [authStatus, setAuthStatus] = useState<AuthStatus>('checking')
    const [user,setUser] = useState<User | null>(null)
    
    const handleLogin = (userId: number): boolean=>{
        
        const user = users.find(user=> user.id == userId)
        if(!user){
            logger.info('user not found')
            setUser(null)
            setAuthStatus('not-authenticated')
            return false
        }

        setUser(user)
        setAuthStatus('authenticated')
        localStorage.setItem('userId', userId.toString())

        return true
    }
    
    const handleLogout = ()=>{
        setAuthStatus('not-authenticated')
        setUser(null)
        localStorage.removeItem('userId') //AQUI!
    }

    //AQUI!
    useEffect(()=>{
        const storedUserId = localStorage.getItem('userId')
        if(storedUserId){
            handleLogin(+storedUserId)
            return
        }
        handleLogout() //si no hay usuario reseteo
    },[])
    
    return (
        <UserContext value={{
            authStatus: authStatus,
            user: user,
            login: handleLogin,
            logout: handleLogout
        }}>
            {children}
        </UserContext>
  )
}
~~~

- Falta implementar la lógica del botón de Salir del ProfilePage

~~~js
import { UserContext } from "@/09-useContext/context/UserContext"
import { Button } from "@/components/ui/button"
import { useContext } from "react"

export const ProfilePage = () => {

  const {user, logout} = useContext(UserContext)
  
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Profile Page</h1>
      <hr />

    <pre className="my-4">{JSON.stringify({user}, null, 2)}</pre>

    <Button variant="destructive" onClick={logout}>Salir</Button>

    </div>
  )
}
~~~

- No hago una redirección porque lo vamos a montar de tal forma que cuando el user ya no está saque automáticamente a la persona de esta pantalla

### Diseño condicional dependiendo de la sesión

- La pantalla de perfil solo deberían verla usuarios activos
- En el AboutPage no debería mostrar la opción de Perfil si no tenemos una sesión iniciada
  - Si tenemos una sesión iniciada, en lugar de Iniciar sesión debería decir Cerrar sesión
- Puedo crearme una bandera en el return del UserContextProvider
- La añado en la interfaz
- UserContext.ts

~~~js
 return (
    <UserContext value={{
        authStatus: authStatus,
        isAuthenticated: authStatus === 'authenticated' ? true: false, //AQUI
        user: user,
        login: handleLogin,
        logout: handleLogout
    }}>
        {children}
    </UserContext>
)
~~~

- En el AboutPage implemento la lógica

~~~js
import { UserContext } from "@/09-useContext/context/UserContext"
import { Button } from "@/components/ui/button"
import { use } from "react"
import { Link } from "react-router"

export const AboutPage = () => {

  const {isAuthenticated, logout}= use(UserContext)

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-4xl font-bold">Página sobre mi</h1>
      <div className="flex flex-col gap-2">
        { isAuthenticated && (
          <Link to="/profile" className="hover:text-blue-500 underline text-2xl">Perfil</Link>
          )
        }
        {
          isAuthenticated ?(
          <Button 
            className="hover:text-blue-500 underline text-2xl"
            variant="destructive"
            onClick={logout}
            >
              Cerrar sesión
          </Button>
          )
          : (
            <Link to="/login" className="hover:text-blue-500 underline text-2xl">Iniciar sesión</Link>
          )
        }
      </div>
    </div>
  )
}
~~~

- De esta manera no está del todo, porque si regreso con el navegador de la pantalla de Profile voy a la pantalla del Login y esto no debería pasar porque ya he iniciado sesión
- También deberíamos ir al AboutPage (o al Login) cuando le doy a Salir de la pantalla Profile

### Rutas privadas y públicas

- Si no tengo usuario no debería poder ver la pantalla del Profile
- Voy a querer crear un componente a parte para validar esto
- Estamos usando la aproximación **DATA de React Router**
- De algún lugar debo poder leer el context, de un customHook, un componente
- Creo un componente que verifique si está dentro del contexto o no
- Si coloco el cursor encima del element del router me dice que es un JSX.Element
- Creo en /router/PrivateRoute.tsx

~~~js
import { use, type JSX } from "react"
import { UserContext } from "../context/UserContext"
import { Navigate } from "react-router"

interface Props{
    element: JSX.Element, //React.Node también es válido
}


const PrivateRoute = ({element}: Props) => {
    //extraigo del context
    const {authStatus} = use(UserContext)

    //verifico y devuelvo un element
    if(authStatus === 'checking'){
        return <div>Loading...</div>
    }
    if (authStatus === 'authenticated'){
        return element
    }

  return <Navigate to='/login' replace />
}

export default PrivateRoute
~~~

- En el router hago uso del componente
- La única pantalla que yo quiero mostrar solo si se está autenticado es el ProfilePage
- app.router.tsx

~~~js
import { createBrowserRouter, Navigate } from "react-router";
import { AboutPage } from "../pages/about/AboutPage";
import { LoginPage } from "../pages/auth/LoginPage";
import { ProfilePage } from "../pages/profile/ProfilePage";
import PrivateRoute from "./PrivateRoute";


export const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AboutPage />,
  },
  {
    path: "/login",
    element: <LoginPage />,
  },
  {
    path: "/profile",
    element: <PrivateRoute element={<ProfilePage />} />
  },
  {
    path: "*",
    element: <Navigate to='/' />,
  },
]);
~~~