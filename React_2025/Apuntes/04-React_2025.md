## 04 GifsApp - Testing

> npm i -D vitest jsdom @testing-library/react @testing-library/dom 

- Los scripts en el package.json

~~~json
"test": "vitest",
"test:ui": "vitest --ui",
"coverage": "vitest run --coverage"
~~~

- Configurar vite.config.ts, el defineConfig ahora viene de vitest/config

~~~js
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react-swc'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  test:{
    environment: 'jsdom',
    globals: true
  }
})
~~~

- Para probar la configuración creo GiffsApp.test.tsx
- Compruebo el snapshot

~~~js
import {describe, expect, test} from 'vitest'
import {render} from '@testing-library/react'
import { GifsApp } from './GifsApp'

describe("GifsApp", ()=>{

    test("should render component properly",()=>{
        
        const {container} = render(<GifsApp />)

        expect(container).toMatchSnapshot()

    })
})
~~~

> npm run test

- Si fuera un componente que siempre luce igual, esta prueba garantiza que siempre sea igual

### Pruebas sobre CustomHeader

- Empecemos por la pieza más fácil
- Puedo usar screen.debug para ver en consola lo que se está renderizando
- CustomHeader.tsx

~~~js

interface Props {
title: string
description?: string
}

export const CustomHeader = ({title, description}: Props) => {
  return (
    <div className="content-center">
        <h1>{title}</h1>
        {description && <p>{description}</p>}
    </div>
  )
}
~~~

- CustomHeader.test.tsx

~~~js
import { describe, expect, test } from "vitest";
import { CustomHeader } from "./CustomHeader";
import { render, screen } from "@testing-library/react";

describe('CustomHeader', ()=>{

    const title = "Test Title"

    test('should render the title correctly', ()=>{
        render(<CustomHeader title={title}/>)

        //puedo buscar el h1 o por el texto Test Title
        expect(screen.getByText(title)).toBeDefined()

    })

    test('should render the description when provided', ()=>{
        const description = "test description"

        render(<CustomHeader title={title} description={description}/>)

        expect(screen.getByText(description)).toBeDefined()
        expect(screen.getByRole('paragraph')).toBeDefined()
        expect(screen.getByRole('paragraph').innerHTML).toBe(description)
    })

    test('should not render the description when not provided', ()=>{
        const {container} = render(<CustomHeader title="Test Title"/>)
        //cuando se usa el screen, el elemento tiene que existir
        //No puedo evaluar la no existencia de un elemento
        //tomo el div por la clase
        const divElement= container.querySelector('.content-center')
        //puedo seleccionar el h1 del título
        const h1 = divElement?.querySelector('h1')
        console.log(h1?.innerHTML)
        //elijo el párrafo de la descriprtion que no debería existir
        const p = divElement?.querySelector('p')
        expect(p).toBeNull()
    })


})
~~~

- Cuando los elementos cambian desde su renderización inicial debo usar **screen** para detectar los cambios

### Pruebas sobre Custom Hooks

- Los hooks solo pueden ser llamados dentro de un functional component o dentro de otro hook
- testing-library ofrece renderHook para renderizar un hook

~~~js
import { renderHook } from "@testing-library/react";
import { describe, test } from "vitest";

describe('useCounter', ()=>{

    test('should initialize with default value of 10', ()=>{

        const {counter} = renderHook(()=> useCounter())
        expect(counter).toBe(10)
    })
})
~~~

- En result.current tengo el handleAdd, handleSubtract, handleReset y counter

~~~js
import { renderHook } from "@testing-library/react";
import { describe, test } from "vitest";

describe('useCounter', ()=>{

    test('should initialize with default value of 10', ()=>{

        const {result} = renderHook(()=> useCounter())
        
        expect(result.current.counter).toBe(10)
    })
})
~~~

- Si ejecuto una función del hook, debo envolverlo en un act (las actualizaciones, un cambio de estado, debe estar envuelto en un act de testing-library)

~~~js
test('should increment counter when handleAdd is called', ()=>{
        
    const {result} = renderHook(()=> useCounter())

    act(()=>{
        result.current.handleAdd()
    })
    
    expect(result.current.counter).toBe(11)//el valor inicial por defecto es 10
})
~~~

- Si la función fuera asíncrona tendría que hacer un async en el act
- Cada modificación de estado debe tener su propio act independiente

~~~js
test('should increment counter when handleAdd is called', ()=>{
        
    const {result} = renderHook(()=> useCounter())

    act(()=>{
        result.current.handleAdd()
        //result.current.handleAdd() seguiría resultando 11
    })

  
   // act(()=>{
       // result.current.handleAdd() con otro act resultaría 12
    //})
    
    expect(result.current.counter).toBe(11)//el valor inicial por defecto es 10
})
~~~

- Para no duplicar constantemente la linea de renderHook se puede usar beforeEach, pero complica demasiado las pruebas en este caso

~~~js
describe('useCounter', ()=>{

  let result;

  beforeEach(()=>{
  const {result:hookValue} = renderHook(()=> useCounter())
  result= hookValue
})

  test('', ()=>{
  {...code}
})

})
~~~

## Componentes con customHooks

- Tenemos que probar un componente que consume un custom hook
- Si toco el botón de +1 que el counter sume 1, si toco el botón de subtract, que reste 1, y si toco reset que resetée a 10
- Pongamos que me quiero asegurar de que tenga los botones, el counter a 10

~~~js
import { render } from "@testing-library/react";
import { describe, expect, test } from "vitest";

describe('myCounterApp', ()=>{

    test('should render the component', ()=>{
        render(<MyCounterApp />)

        expect(screen.getByRole('heading', {level:1}).innerHTML).toContain('counter: 10')

        expect(screen.getByRole('button', {name: '+1'})).toBeDefined()
        expect(screen.getByRole('button', {name: '-1'})).toBeDefined()
        expect(screen.getByRole('button', {name: 'Reset'})).toBeDefined()
    }) 
})
~~~

- Uso fireEvent para disprar un evento

~~~js
test('should increment the counter', ()=>{
    const labelH1 = screen.getByRole('heading', {level:1})
    const button = screen.getByRole('button', {name: '+1'})

    fireEvent.click(button)

    expect(labelH1.innerHTML).toContain('counter: 11')

    })
~~~

### Simular estado de un customHook

- Pongamos que este customHook de useCounter fuera muy complejo
- Yo puedo querer simular el estado de un customHook (hacer un mock)
- Para hacer el mock necesito el path del hook
- Tengo que usar el mismo nombre en el callback (useCOunter) que es una función en este caso 
- Tengo que regresar un objeto igual que el que regresa el customHook (con el handleAdd, handleSUbtract, etc)
- Si ahora hago un screen.debug, me devuelve 20 en consola (en el counter)

~~~js
import { fireEvent, render } from "@testing-library/react";
import { describe, expect, test, vi } from "vitest";


vi.mock('/path/mi/hook', ()=>{
    useCounter: ()=>({
        counter: 20,
        handleAdd: vi.fn(),
        handleSubtract: vi.fn(),
        handleReset: vi.fn()
    })
})

describe('myCounterApp', ()=>{

    test('should render the component', ()=>{
        render(<MyCounterApp />)
        screen.debug() //counter:20
    }) 
})
~~~

- Para comprobar que la función fue llamada, debo elevar la función (porque en el objeto vi.fn() es una función anónima)

~~~js
import { fireEvent, render } from "@testing-library/react";
import { describe, expect, test, vi } from "vitest";


const handleAddMock = vi.fn()
const handleSubtractMock = vi.fn()
const handleResetMock = vi.fn()

vi.mock('/path/mi/hook', ()=>{
    useCounter: ()=>({
        counter: 20,
        handleAdd: handleAddMock,
        handleSubtract: handleSubtractMock,
        handleReset: handleResetMock
    })
})

describe('myCounterApp', ()=>{
    test('should call handleAdd if button is clicked', ()=>{
         render(<MyCounterApp />)

         const button = screen.getByRole('button', {name:+1})

         fireEvent.click(button)

         expect(handleAddMock).toHaveBeenCalled()
         expect(handleSubtractMock).not.toHaveBeenCalled()
    }) 
})
~~~

- Puedo usar toHaveBeenCalledTimes para evaluar cuántas veces se ha llamado la función

### Prueba sobre instancias de axios

- /api/giphy.api.ts

~~~js
import axios from "axios";


export const giphyApi = axios.create({
    baseURL: 'https://api.giphy.com/v1/gifs',
    params:{
        lang: 'es',
        api_key: import.meta.env.VITE_GIFS_APIKEY
    }
})
~~~

- Creo el test. Con .defaults veo mucha info
- La que me interesa es baseURL y params

~~~js
import { describe, test } from "vitest";
import { giphyApi } from "./giphy.api";

describe('giphyApi', ()=>{

    test('should be configured correctly', ()=>{
        console.log(giphyApi.defaults)
    })
})
~~~

- Uso el toStrictEqual (o toEqual) para evaluar objetos, y el toBe para primitivos

~~~js
import { describe, expect, test } from "vitest";
import { giphyApi } from "./giphy.api";

describe('giphyApi', ()=>{

    test('should be configured correctly', ()=>{

        const params = giphyApi.defaults.params

        expect(giphyApi.defaults.baseURL).toBe('https://api.giphy.com/v1/gifs')
        expect(params.lang).toBe('es')
        expect(params.api_key).toBe(import.meta.env.VITE_GIFS_APIKEY)

        //puedo evaluar el objeto de params

        expect(params).toStrictEqual({
            lang: 'es',
            api_key: import.meta.env.VITE_GIFS_APIKEY
        })
    })
})
~~~

### Pruebas sobre acción getGifsByQuery

~~~js
import type { GiphyResponse } from "../interfaces/giphy.response"
import type { Gif } from "../interfaces/gif.interface"
import { giphyApi } from "../api/giphy.api"


export const getGifsByQuery = async (query: string): Promise<Gif[]>=>{

    const response = await giphyApi<GiphyResponse>(`/search`, {
        params:{
            q:query,
            limit:10,
        }
    })

    return response.data.data.map((gif)=>({
        id: gif.id,
        title: gif.title ,
        url: gif.images.original.url,
        width: Number(gif.images.original.width),
        height: Number(gif.images.original.height),
    }))
}
~~~

- Para obtener los gifs

~~~js
import { describe, test } from "vitest";
import { getGifsByQuery } from "./get-gifs-by-query.action";

describe('getGifsByQuery', ()=>{

    test('should return a list of gifs', async ()=>{
        const gifs = await getGifsByQuery('goku')

        console.log(gifs)
    })
})
~~~

- Creo una carpeta a nibvel de root con tests/mock.gifs.data.ts y copio el resultado de la petición

~~~js
export const mockDataGifs = [
  {
    id: 'u07Eq016TuYAFpmpfp',
    title: 'Goku GIF',
    url: 'https://media3.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/u07Eq016TuYAFpmpfp/giphy.gif',
    width: 480,
    height: 394
  },
  {
    id: 'B6SyssSlTgPXq',
    title: 'Dragonball Goku Super Saiyan GIF',
    url: 'https://media0.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/B6SyssSlTgPXq/giphy.gif',
    width: 200,
    height: 200
  },
  {
    id: 'CY3A9zOlZR8uhFbeok',
    title: 'Dragon Ball Super Ultra Instinct GIF by Toei Animation',
    url: 'https://media2.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/CY3A9zOlZR8uhFbeok/giphy.gif',
    width: 480,
    height: 278
  },
  {
    id: 'WOb8EeFziTQNE02WXs',
    title: 'Dragon Ball Super GIF by Toei Animation',
    url: 'https://media0.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/WOb8EeFziTQNE02WXs/giphy.gif',
    width: 540,
    height: 304
  },
  {
    id: 'zKRlxWqdP4NTok3Ppl',
    title: 'Dragon Ball GIF by Toei Animation',
    url: 'https://media3.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/zKRlxWqdP4NTok3Ppl/giphy.gif',
    width: 500,
    height: 360
  },
  {
    id: 'SIuI7syOPvm1HAd5GF',
    title: 'Dragon Ball Super Ultra Instinct GIF by Toei Animation',
    url: 'https://media4.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/SIuI7syOPvm1HAd5GF/giphy.gif',
    width: 500,
    height: 281
  },
  {
    id: '977YesTjNfQC7vQiph',
    title: 'Dragon Ball GIF by Toei Animation',
    url: 'https://media0.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/977YesTjNfQC7vQiph/giphy.gif',
    width: 498,
    height: 278
  },
  {
    id: 'aAbax5anloMNk6TSP9',
    title: 'Dragon Ball GIF by Toei Animation',
    url: 'https://media3.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/aAbax5anloMNk6TSP9/giphy.gif',
    width: 540,
    height: 294
  },
  {
    id: 'MQ08dsDSArNtEzf2kk',
    title: '',
    url: 'https://media4.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/MQ08dsDSArNtEzf2kk/giphy.gif',
    width: 480,
    height: 270
  },
  {
    id: 'dxld1UBIiGuoh31Fus',
    title: 'Dragon Ball GIF by Toei Animation',
    url: 'https://media0.giphy.com/media/v1.Y2lkPTU4OWQwNTNjbWxneWh0bjJ0aGV3ZGV3NnVjbDhsNGttbHFiOGVod3IwNWdwYzlsMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/dxld1UBIiGuoh31Fus/giphy.gif',
    width: 464,
    height: 260
  }
]
~~~

- Uso expect.any(tipo)

~~~js
import { describe, expect, test } from "vitest";
import { getGifsByQuery } from "./get-gifs-by-query.action";

describe('getGifsByQuery', ()=>{

    test('should return a list of gifs', async ()=>{
        const gifs = await getGifsByQuery('goku')

        const [gif1] = gifs //desestructuro el primer gif por posicion en el arreglo

        expect(gifs.length).toBe(10)

        expect(gif1).toStrictEqual({
            id: expect.any(String),
            title: expect.any(String),
            height: expect.any(Number),
            width: expect.any(Number),
            url: expect.any(String)
        })
    })
})
~~~

### Axios mock adapter - Controlar resultados de axios

- 